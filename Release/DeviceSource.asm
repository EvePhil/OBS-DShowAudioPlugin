; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\beeanyew\Documents\GitHub\OBS\DShowAudioPlugin\DeviceSource.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?SetInt@DeviceSource@@UAEXPB_WH@Z		; DeviceSource::SetInt
PUBLIC	?SetFloat@DeviceSource@@UAEXPB_WM@Z		; DeviceSource::SetFloat
PUBLIC	?GlobalSourceEnterScene@DeviceSource@@UAEXXZ	; DeviceSource::GlobalSourceEnterScene
PUBLIC	?GlobalSourceLeaveScene@DeviceSource@@UAEXXZ	; DeviceSource::GlobalSourceLeaveScene
PUBLIC	?EndScene@DeviceSource@@UAEXXZ			; DeviceSource::EndScene
PUBLIC	?BeginScene@DeviceSource@@UAEXXZ		; DeviceSource::BeginScene
PUBLIC	?UpdateSettings@DeviceSource@@UAEXXZ		; DeviceSource::UpdateSettings
PUBLIC	?Render@DeviceSource@@UAEXABUVect2@@0@Z		; DeviceSource::Render
PUBLIC	?Preprocess@DeviceSource@@UAEXXZ		; DeviceSource::Preprocess
PUBLIC	??_R4DeviceSource@@6B@				; DeviceSource::`RTTI Complete Object Locator'
PUBLIC	??_R3DeviceSource@@8				; DeviceSource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DeviceSource@@8				; DeviceSource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ImageSource@@8			; ImageSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3ImageSource@@8				; ImageSource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ImageSource@@8				; ImageSource::`RTTI Base Class Array'
PUBLIC	??_R0?AVImageSource@@@8				; ImageSource `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@DeviceSource@@8			; DeviceSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDeviceSource@@@8			; DeviceSource `RTTI Type Descriptor'
PUBLIC	??1?$List@PAUSampleData@@@@QAE@XZ		; List<SampleData *>::~List<SampleData *>
PUBLIC	?GetSize@DeviceSource@@UBE?AUVect2@@XZ		; DeviceSource::GetSize
PUBLIC	??_GDeviceSource@@UAEPAXI@Z			; DeviceSource::`scalar deleting destructor'
PUBLIC	?DeleteMediaType@@YAXPAU_AMMediaType@@@Z	; DeleteMediaType
PUBLIC	?msetd@@YGXPAXKI@Z				; msetd
PUBLIC	?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ; CreateTexture
PUBLIC	?FreeData@MediaOutputInfo@@QAEXXZ		; MediaOutputInfo::FreeData
PUBLIC	??0?$List@E@@QAE@XZ				; List<unsigned char>::List<unsigned char>
PUBLIC	??0DeviceAudioSource@@QAE@XZ			; DeviceAudioSource::DeviceAudioSource
PUBLIC	??0?$List@UMediaOutputInfo@@@@QAE@XZ		; List<MediaOutputInfo>::List<MediaOutputInfo>
PUBLIC	?Clear@?$List@UMediaOutputInfo@@@@QAEXXZ	; List<MediaOutputInfo>::Clear
PUBLIC	??1?$List@UMediaOutputInfo@@@@QAE@XZ		; List<MediaOutputInfo>::~List<MediaOutputInfo>
PUBLIC	?Num@?$List@UMediaOutputInfo@@@@QBEIXZ		; List<MediaOutputInfo>::Num
PUBLIC	??A?$List@UMediaOutputInfo@@@@QAEAAUMediaOutputInfo@@I@Z ; List<MediaOutputInfo>::operator[]
PUBLIC	??0SampleData@@QAE@XZ				; SampleData::SampleData
PUBLIC	?mcpyrev@@YGXPAXPBXI@Z				; mcpyrev
PUBLIC	?Add@?$List@PAUSampleData@@@@QAEIABQAUSampleData@@@Z ; List<SampleData *>::Add
PUBLIC	?Insert@?$List@PAUSampleData@@@@QAEXIABQAUSampleData@@@Z ; List<SampleData *>::Insert
PUBLIC	??_R0?AUMediaOutputInfo@@@8			; MediaOutputInfo `RTTI Type Descriptor'
PUBLIC	??_7DeviceSource@@6B@				; DeviceSource::`vftable'
EXTRN	?GetMatrix@ImageSource@@UBE_NPB_WAAUMatrix@@@Z:PROC ; ImageSource::GetMatrix
EXTRN	?GetVector4@ImageSource@@UBE_NPB_WAAUVect4@@@Z:PROC ; ImageSource::GetVector4
EXTRN	?GetVector2@ImageSource@@UBE_NPB_WAAUVect2@@@Z:PROC ; ImageSource::GetVector2
EXTRN	?GetVector@ImageSource@@UBE_NPB_WAAUVect@@@Z:PROC ; ImageSource::GetVector
EXTRN	?GetString@ImageSource@@UBE_NPB_WAAVString@@@Z:PROC ; ImageSource::GetString
EXTRN	?GetInt@ImageSource@@UBE_NPB_WAAH@Z:PROC	; ImageSource::GetInt
EXTRN	?GetFloat@ImageSource@@UBE_NPB_WAAM@Z:PROC	; ImageSource::GetFloat
EXTRN	?SetMatrix@ImageSource@@UAEXPB_WABUMatrix@@@Z:PROC ; ImageSource::SetMatrix
EXTRN	?SetVector4@ImageSource@@UAEXPB_WABUVect4@@@Z:PROC ; ImageSource::SetVector4
EXTRN	?SetVector2@ImageSource@@UAEXPB_WABUVect2@@@Z:PROC ; ImageSource::SetVector2
EXTRN	?SetVector@ImageSource@@UAEXPB_WABUVect@@@Z:PROC ; ImageSource::SetVector
EXTRN	?SetString@ImageSource@@UAEXPB_W0@Z:PROC	; ImageSource::SetString
EXTRN	?Tick@ImageSource@@UAEXM@Z:PROC			; ImageSource::Tick
EXTRN	_IID_IFilterGraph:BYTE
EXTRN	_IID_ICaptureGraphBuilder2:BYTE
EXTRN	_CLSID_CaptureGraphBuilder2:BYTE
EXTRN	_CLSID_FilterGraph:BYTE
EXTRN	__imp_??_7ImageSource@@6B@:BYTE
EXTRN	__imp_??1ImageSource@@UAE@XZ:PROC
EXTRN	__imp_?Tick@ImageSource@@UAEXM@Z:PROC
EXTRN	__imp_?SetString@ImageSource@@UAEXPB_W0@Z:PROC
EXTRN	__imp_?SetVector@ImageSource@@UAEXPB_WABUVect@@@Z:PROC
EXTRN	__imp_?SetVector2@ImageSource@@UAEXPB_WABUVect2@@@Z:PROC
EXTRN	__imp_?SetVector4@ImageSource@@UAEXPB_WABUVect4@@@Z:PROC
EXTRN	__imp_?SetMatrix@ImageSource@@UAEXPB_WABUMatrix@@@Z:PROC
EXTRN	__imp_?GetFloat@ImageSource@@UBE_NPB_WAAM@Z:PROC
EXTRN	__imp_?GetInt@ImageSource@@UBE_NPB_WAAH@Z:PROC
EXTRN	__imp_?GetString@ImageSource@@UBE_NPB_WAAVString@@@Z:PROC
EXTRN	__imp_?GetVector@ImageSource@@UBE_NPB_WAAUVect@@@Z:PROC
EXTRN	__imp_?GetVector2@ImageSource@@UBE_NPB_WAAUVect2@@@Z:PROC
EXTRN	__imp_?GetVector4@ImageSource@@UBE_NPB_WAAUVect4@@@Z:PROC
EXTRN	__imp_?GetMatrix@ImageSource@@UBE_NPB_WAAUMatrix@@@Z:PROC
EXTRN	__imp_??0Vect2@@QAE@MM@Z:PROC
EXTRN	??_EDeviceSource@@UAEPAXI@Z:PROC		; DeviceSource::`vector deleting destructor'
EXTRN	_FORMAT_WaveFormatEx:BYTE
EXTRN	__imp_?Log@@YAXPB_WZZ:PROC
EXTRN	__imp_??0String@@QAE@XZ:PROC
EXTRN	__imp_??4String@@QAEAAV0@PB_W@Z:PROC
EXTRN	__imp_??4String@@QAEAAV0@ABV0@@Z:PROC
EXTRN	__imp_?Compare@String@@QBEHPB_W@Z:PROC
EXTRN	__imp_?IsEmpty@String@@QBEHXZ:PROC
EXTRN	__imp_?IsValid@String@@QBEHXZ:PROC
EXTRN	__imp_?FormattedString@@YA?AVString@@PB_WZZ:PROC
EXTRN	__imp_??ZVect4@@QAEAAU0@M@Z:PROC
EXTRN	__imp_?GS@@3PAVGraphicsSystem@@A:DWORD
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	_IID_IAMStreamConfig:BYTE
EXTRN	_IID_IMediaControl:BYTE
EXTRN	_CLSID_DSoundRender:BYTE
EXTRN	_CLSID_VideoInputDeviceCategory:BYTE
EXTRN	_CLSID_AudioInputDeviceCategory:BYTE
EXTRN	_CLSID_AudioRendererCategory:BYTE
EXTRN	_PIN_CATEGORY_CAPTURE:BYTE
EXTRN	__imp__CoTaskMemFree@4:PROC
EXTRN	__imp_??0AudioSource@@QAE@XZ:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp_?OSTerminateThread@@YGHPAXK@Z:PROC
EXTRN	__imp_?OSDebugOut@@YAXPB_WZZ:PROC
EXTRN	__imp_?GetFloat@XElement@@QBEMPB_WM@Z:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp_?OSGetTotalCores@@YGHXZ:PROC
EXTRN	__imp_?SetVolume@AudioSource@@QAEXM@Z:PROC
EXTRN	_IID_IBasicAudio:BYTE
EXTRN	__imp_??0String@@QAE@PB_W@Z:PROC
EXTRN	__imp_??1String@@QAE@XZ:PROC
EXTRN	__imp_?CompareI@String@@QBEHPB_W@Z:PROC
EXTRN	__imp_??BString@@QBEPA_WXZ:PROC
EXTRN	__imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z:PROC
EXTRN	__imp_?GetInt@XElement@@QBEHPB_WH@Z:PROC
EXTRN	__imp_?SetTimeOffset@AudioSource@@QAEXH@Z:PROC
EXTRN	__imp_?scmpi@@YGHPB_W0@Z:PROC
;	COMDAT ??_7DeviceSource@@6B@
CONST	SEGMENT
??_7DeviceSource@@6B@ DD FLAT:??_R4DeviceSource@@6B@	; DeviceSource::`vftable'
	DD	FLAT:??_EDeviceSource@@UAEPAXI@Z
	DD	FLAT:?Preprocess@DeviceSource@@UAEXXZ
	DD	FLAT:?Tick@ImageSource@@UAEXM@Z
	DD	FLAT:?Render@DeviceSource@@UAEXABUVect2@@0@Z
	DD	FLAT:?GetSize@DeviceSource@@UBE?AUVect2@@XZ
	DD	FLAT:?UpdateSettings@DeviceSource@@UAEXXZ
	DD	FLAT:?BeginScene@DeviceSource@@UAEXXZ
	DD	FLAT:?EndScene@DeviceSource@@UAEXXZ
	DD	FLAT:?GlobalSourceLeaveScene@DeviceSource@@UAEXXZ
	DD	FLAT:?GlobalSourceEnterScene@DeviceSource@@UAEXXZ
	DD	FLAT:?SetFloat@DeviceSource@@UAEXPB_WM@Z
	DD	FLAT:?SetInt@DeviceSource@@UAEXPB_WH@Z
	DD	FLAT:?SetString@ImageSource@@UAEXPB_W0@Z
	DD	FLAT:?SetVector@ImageSource@@UAEXPB_WABUVect@@@Z
	DD	FLAT:?SetVector2@ImageSource@@UAEXPB_WABUVect2@@@Z
	DD	FLAT:?SetVector4@ImageSource@@UAEXPB_WABUVect4@@@Z
	DD	FLAT:?SetMatrix@ImageSource@@UAEXPB_WABUMatrix@@@Z
	DD	FLAT:?GetFloat@ImageSource@@UBE_NPB_WAAM@Z
	DD	FLAT:?GetInt@ImageSource@@UBE_NPB_WAAH@Z
	DD	FLAT:?GetString@ImageSource@@UBE_NPB_WAAVString@@@Z
	DD	FLAT:?GetVector@ImageSource@@UBE_NPB_WAAUVect@@@Z
	DD	FLAT:?GetVector2@ImageSource@@UBE_NPB_WAAUVect2@@@Z
	DD	FLAT:?GetVector4@ImageSource@@UBE_NPB_WAAUVect4@@@Z
	DD	FLAT:?GetMatrix@ImageSource@@UBE_NPB_WAAUMatrix@@@Z
CONST	ENDS
;	COMDAT ??_R4DeviceSource@@6B@
rdata$r	SEGMENT
??_R4DeviceSource@@6B@ DD 00H				; DeviceSource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDeviceSource@@@8
	DD	FLAT:??_R3DeviceSource@@8
rdata$r	ENDS
;	COMDAT ??_R3DeviceSource@@8
rdata$r	SEGMENT
??_R3DeviceSource@@8 DD 00H				; DeviceSource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DeviceSource@@8
rdata$r	ENDS
;	COMDAT ??_R2DeviceSource@@8
rdata$r	SEGMENT
??_R2DeviceSource@@8 DD FLAT:??_R1A@?0A@EA@DeviceSource@@8 ; DeviceSource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ImageSource@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ImageSource@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ImageSource@@8 DD FLAT:??_R0?AVImageSource@@@8 ; ImageSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ImageSource@@8
rdata$r	ENDS
;	COMDAT ??_R3ImageSource@@8
rdata$r	SEGMENT
??_R3ImageSource@@8 DD 00H				; ImageSource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ImageSource@@8
rdata$r	ENDS
;	COMDAT ??_R2ImageSource@@8
rdata$r	SEGMENT
??_R2ImageSource@@8 DD FLAT:??_R1A@?0A@EA@ImageSource@@8 ; ImageSource::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVImageSource@@@8
_DATA	SEGMENT
??_R0?AVImageSource@@@8 DD FLAT:??_7type_info@@6B@	; ImageSource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVImageSource@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@DeviceSource@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DeviceSource@@8 DD FLAT:??_R0?AVDeviceSource@@@8 ; DeviceSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DeviceSource@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDeviceSource@@@8
_DATA	SEGMENT
??_R0?AVDeviceSource@@@8 DD FLAT:??_7type_info@@6B@	; DeviceSource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDeviceSource@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AUMediaOutputInfo@@@8
_DATA	SEGMENT
??_R0?AUMediaOutputInfo@@@8 DD FLAT:??_7type_info@@6B@	; MediaOutputInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUMediaOutputInfo@@', 00H
$SG-5555 DB	00H
	ORG $+2
$SG-5556 DB	00H, 00H
	ORG $+2
$SG-5574 DB	'M', 00H, 'J', 00H, 'P', 00H, 'G', 00H, 00H, 00H
	ORG $+2
$SG-5573 DB	'd', 00H, 'v', 00H, 'h', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG-5572 DB	'd', 00H, 'v', 00H, 's', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG-5571 DB	'd', 00H, 'v', 00H, 's', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG-5570 DB	'H', 00H, '2', 00H, '6', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG-5569 DB	'M', 00H, 'P', 00H, 'E', 00H, 'G', 00H, '2', 00H, '_', 00H
	DB	'V', 00H, 'I', 00H, 'D', 00H, 'E', 00H, 'O', 00H, 00H, 00H
$SG-5568 DB	'H', 00H, 'D', 00H, 'Y', 00H, 'C', 00H, 00H, 00H
	ORG $+2
$SG-5567 DB	'U', 00H, 'Y', 00H, 'V', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG-5566 DB	'Y', 00H, 'U', 00H, 'Y', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG-5565 DB	'Y', 00H, 'V', 00H, 'Y', 00H, 'U', 00H, 00H, 00H
	ORG $+2
$SG-5564 DB	'Y', 00H, 'V', 00H, 'U', 00H, '9', 00H, 00H, 00H
	ORG $+2
$SG-5563 DB	'Y', 00H, '4', 00H, '1', 00H, 'P', 00H, 00H, 00H
	ORG $+2
$SG-5562 DB	'Y', 00H, 'V', 00H, '1', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG-5561 DB	'I', 00H, '4', 00H, '2', 00H, '0', 00H, 00H, 00H
	ORG $+2
$SG-5560 DB	'R', 00H, 'G', 00H, 'B', 00H, 'A', 00H, '3', 00H, '2', 00H
	DB	00H, 00H
	ORG $+2
$SG-5559 DB	'R', 00H, 'G', 00H, 'B', 00H, '3', 00H, '2', 00H, 00H, 00H
$SG-5558 DB	'R', 00H, 'G', 00H, 'B', 00H, '2', 00H, '4', 00H, 00H, 00H
$SG-5557 DB	'N', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG-5578 DB	'U', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'd', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's'
	DB	00H, 'h', 00H, 'o', 00H, 'w', 00H, ' ', 00H, 'a', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'p'
	DB	00H, 'u', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG-5575 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'i', 00H, 'l', 00H
	DB	'd', 00H, ' ', 00H, 'I', 00H, 'G', 00H, 'r', 00H, 'a', 00H, 'p'
	DB	00H, 'h', 00H, 'B', 00H, 'u', 00H, 'i', 00H, 'l', 00H, 'd', 00H
	DB	'e', 00H, 'r', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's'
	DB	00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, '=', 00H, ' ', 00H
	DB	'%', 00H, '0', 00H, '8', 00H, 'l', 00H, 'X', 00H, 00H, 00H
$SG-5576 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'i', 00H, 'l', 00H
	DB	'd', 00H, ' ', 00H, 'I', 00H, 'C', 00H, 'a', 00H, 'p', 00H, 't'
	DB	00H, 'u', 00H, 'r', 00H, 'e', 00H, 'G', 00H, 'r', 00H, 'a', 00H
	DB	'p', 00H, 'h', 00H, 'B', 00H, 'u', 00H, 'i', 00H, 'l', 00H, 'd'
	DB	00H, 'e', 00H, 'r', 00H, '2', 00H, ',', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, '='
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, 'l', 00H, 'X', 00H
	DB	00H, 00H
$SG-5577 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'c', 00H
	DB	'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H, 'o'
	DB	00H, 't', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'm', 00H, 'u', 00H, 't', 00H
	DB	'e', 00H, 'x', 00H, 00H, 00H
$SG-5579 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'd', 00H, 'e', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'u'
	DB	00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'f', 00H, 'o', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'b', 00H, 'i'
	DB	00H, 't', 00H, 's', 00H, ' ', 00H, 'p', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 'u', 00H, ',', 00H, ' ', 00H
	DB	'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l'
	DB	00H, 's', 00H, ':', 00H, ' ', 00H, '%', 00H, 'u', 00H, ',', 00H
	DB	' ', 00H, 's', 00H, 'a', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e'
	DB	00H, 's', 00H, ' ', 00H, 'p', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'c', 00H, ':', 00H, ' ', 00H, '%', 00H, 'u'
	DB	00H, ',', 00H, ' ', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG-5580 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'f', 00H, 'o'
	DB	00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'w', 00H
	DB	'a', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 'a', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 'r', 00H, 'm', 00H
	DB	'a', 00H, 'l', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 'v', 00H, 'e'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H
	DB	't', 00H, 00H, 00H
$SG-5581 DB	'f', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'C', 00H
	DB	'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H, 'A', 00H, 'u'
	DB	00H, 'd', 00H, 'i', 00H, 'o', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG-5582 DB	'c', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H
	DB	'R', 00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG-5583 DB	'd', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG-5584 DB	'd', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG-5585 DB	'd', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'I', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG-5586 DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG-5587 DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'N', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG-5588 DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'I', 00H, 'D'
	DB	00H, 00H, 00H
$SG-5589 DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'C', 00H, 'L'
	DB	00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG-5590 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, '_', 00H
	DB	'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'I', 00H, 'n'
	DB	00H, 'p', 00H, 'u', 00H, 't', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG-5591 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, '_', 00H
	DB	'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 'I', 00H, 'n'
	DB	00H, 'p', 00H, 'u', 00H, 't', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG-5592 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, '_', 00H
	DB	'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'R', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'r', 00H
	DB	'C', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r'
	DB	00H, 'y', 00H, 00H, 00H
$SG-5593 DB	'f', 00H, 'l', 00H, 'i', 00H, 'p', 00H, 'I', 00H, 'm', 00H
	DB	'a', 00H, 'g', 00H, 'e', 00H, 00H, 00H
$SG-5594 DB	'f', 00H, 'l', 00H, 'i', 00H, 'p', 00H, 'I', 00H, 'm', 00H
	DB	'a', 00H, 'g', 00H, 'e', 00H, 'H', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'z', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H
$SG-5595 DB	'o', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, 00H, 00H
$SG-5596 DB	'v', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG-5597 DB	'u', 00H, 's', 00H, 'e', 00H, 'C', 00H, 'h', 00H, 'r', 00H
	DB	'o', 00H, 'm', 00H, 'a', 00H, 'K', 00H, 'e', 00H, 'y', 00H, 00H
	DB	00H
	ORG $+2
$SG-5598 DB	'k', 00H, 'e', 00H, 'y', 00H, 'C', 00H, 'o', 00H, 'l', 00H
	DB	'o', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG-5599 DB	'k', 00H, 'e', 00H, 'y', 00H, 'S', 00H, 'i', 00H, 'm', 00H
	DB	'i', 00H, 'l', 00H, 'a', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'y'
	DB	00H, 00H, 00H
$SG-5600 DB	'k', 00H, 'e', 00H, 'y', 00H, 'B', 00H, 'l', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG-5601 DB	'k', 00H, 'e', 00H, 'y', 00H, 'S', 00H, 'p', 00H, 'i', 00H
	DB	'l', 00H, 'l', 00H, 'R', 00H, 'e', 00H, 'd', 00H, 'u', 00H, 'c'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG-5602 DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'P', 00H, 'a', 00H, 't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG-5603 DB	'F', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'l', 00H, 'y', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG-5605 DB	's', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, 'T', 00H, 'y'
	DB	00H, 'p', 00H, 'e', 00H, 00H, 00H
$SG-5620 DB	'c', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H
$SG-5604 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'I', 00H
	DB	'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' '
	DB	00H, 'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'''', 00H, '%', 00H, 's', 00H, '''', 00H, ',', 00H, ' ', 00H, 'p'
	DB	00H, 'a', 00H, 't', 00H, 'h', 00H, ' ', 00H, '''', 00H, '%', 00H
	DB	's', 00H, '''', 00H, 00H, 00H
	ORG $+2
$SG-5607 DB	's', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'T', 00H
	DB	'i', 00H, 'm', 00H, 'e', 00H, 'O', 00H, 'f', 00H, 'f', 00H, 's'
	DB	00H, 'e', 00H, 't', 00H, 00H, 00H
$SG-5622 DB	'd', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H
	DB	00H
	ORG $+2
$SG-5606 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'N', 00H
	DB	'o', 00H, ' ', 00H, 'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, ' ', 00H, 'p', 00H, 'i', 00H, 'n', 00H, ',', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG-5624 DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG-5608 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'a', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'v'
	DB	00H, 'i', 00H, 'c', 00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ',', 00H, 0dH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e'
	DB	00H, ' ', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	',', 00H, 0dH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG-5626 DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG-5631 DB	'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 'I', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'a', 00H, 'l'
	DB	00H, 00H, 00H
$SG-5609 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, 00H, 00H
	ORG $+2
$SG-5610 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'a', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'M', 00H, 'e', 00H, 'd'
	DB	00H, 'i', 00H, 'a', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'N', 00H, 'e', 00H, 'x', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H
	DB	'0', 00H, '8', 00H, 'l', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG-5611 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'a', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'M', 00H, 'e', 00H, 'd'
	DB	00H, 'i', 00H, 'a', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	's', 00H, '-', 00H, '>', 00H, 'N', 00H, 'e', 00H, 'x', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	'd', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H
	DB	'0', 00H, '8', 00H, 'l', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG-5612 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'C', 00H
	DB	'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H, 'o'
	DB	00H, 't', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'f'
	DB	00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, ',', 00H
	DB	' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't'
	DB	00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H
	DB	'l', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG-5630 DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG-5633 DB	'r', 00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'H', 00H, 'e', 00H, 'i'
	DB	00H, 'g', 00H, 'h', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG-5613 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'd', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H, 'c'
	DB	00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H
	DB	' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'e'
	DB	00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, '=', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, 'l', 00H, 'X', 00H, 00H
	DB	00H
$SG-5634 DB	'c', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H
	DB	'R', 00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG-5614 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'f', 00H
	DB	'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG-5635 DB	'u', 00H, 's', 00H, 'e', 00H, 'P', 00H, 'r', 00H, 'e', 00H
	DB	'f', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'd', 00H, 'T'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG-5615 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'P', 00H
	DB	'l', 00H, 'u', 00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, 'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'n'
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'r', 00H, ',', 00H
	DB	' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't'
	DB	00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H
	DB	'l', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG-5632 DB	'r', 00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'W', 00H, 'i', 00H, 'd'
	DB	00H, 't', 00H, 'h', 00H, 00H, 00H
$SG-5636 DB	'p', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 00H, 00H
$SG-5616 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'd', 00H, ' ', 00H
	DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'c'
	DB	00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H
	DB	' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'e'
	DB	00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, '=', 00H
	DB	' ', 00H, '%', 00H, '0', 00H, '8', 00H, 'l', 00H, 'X', 00H, 00H
	DB	00H
	ORG $+2
$SG-5617 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'd', 00H, ' ', 00H
	DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'd'
	DB	00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'r', 00H, 'a', 00H
	DB	'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's'
	DB	00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, '=', 00H, ' ', 00H
	DB	'%', 00H, '0', 00H, '8', 00H, 'l', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG-5637 DB	's', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, 'T', 00H, 'y'
	DB	00H, 'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG-5618 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e'
	DB	00H, ' ', 00H, 'p', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 't', 00H
	DB	'o', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'a'
	DB	00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ' '
	DB	00H, 'p', 00H, 'i', 00H, 'n', 00H, ',', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H, '='
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, 'l', 00H, 'X', 00H
	DB	00H, 00H
	ORG $+2
$SG-5619 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	'I', 00H, 'M', 00H, 'e', 00H, 'd', 00H, 'i', 00H, 'a', 00H, 'C'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H
	DB	',', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l'
	DB	00H, 't', 00H, ' ', 00H, '=', 00H, ' ', 00H, '%', 00H, '0', 00H
	DB	'8', 00H, 'l', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG-5621 DB	'r', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '%', 00H, 's', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'f', 00H, 's', 00H, ' ', 00H, 'w', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, 'l', 00H, 'e', 00H, 'f', 00H, 't', 00H, 0dH, 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+2
$SG-5623 DB	'r', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '%', 00H, 's', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'f', 00H, 's', 00H, ' ', 00H, 'w', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, 'l', 00H, 'e', 00H, 'f', 00H, 't', 00H, 0dH, 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+2
$SG-5625 DB	'r', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '%', 00H, 's', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'f', 00H, 's', 00H, ' ', 00H, 'w', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, 'l', 00H, 'e', 00H, 'f', 00H, 't', 00H, 0dH, 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+2
$SG-5627 DB	'r', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '%', 00H, 's', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'f', 00H, 's', 00H, ' ', 00H, 'w', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, 'l', 00H, 'e', 00H, 'f', 00H, 't', 00H, 0dH, 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+2
$SG-5628 DB	'D', 00H, 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'A', 00H
	DB	'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 'P', 00H, 'l', 00H, 'u'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'l', 00H, '-'
	DB	00H, '>', 00H, 'R', 00H, 'u', 00H, 'n', 00H, ' ', 00H, 'f', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H
	DB	' ', 00H, '=', 00H, ' ', 00H, '%', 00H, '0', 00H, '8', 00H, 'l'
	DB	00H, 'X', 00H, 00H, 00H
$SG-5629 DB	'v', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG-5638 DB	't', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'O', 00H, 'f', 00H
	DB	'f', 00H, 's', 00H, 'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG-5639 DB	'v', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@PAUSampleData@@@@QAEIABQAUSampleData@@@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?Add@?$List@PAUSampleData@@@@QAEIABQAUSampleData@@@Z PROC ; List<SampleData *>::Add, COMDAT
; _this$ = esi

; 40   :     {

	push	ebp
	mov	ebp, esp

; 41   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	inc	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	add	eax, eax
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	edx

; 42   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4-4], edx

; 43   :         return num-1;

	mov	eax, DWORD PTR [esi+4]
	dec	eax

; 44   :     }

	pop	ebp
	ret	4
?Add@?$List@PAUSampleData@@@@QAEIABQAUSampleData@@@Z ENDP ; List<SampleData *>::Add
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$List@UMediaOutputInfo@@@@QAEAAUMediaOutputInfo@@I@Z
_TEXT	SEGMENT
??A?$List@UMediaOutputInfo@@@@QAEAAUMediaOutputInfo@@I@Z PROC ; List<MediaOutputInfo>::operator[], COMDAT
; _this$ = esi
; _index$ = eax

; 375  :         assert(index < num);
; 376  :         if(index >= num) {CrashError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LN1@operator
	push	eax
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUMediaOutputInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH

; 378  :     }

	ret	0
$LN1@operator:

; 377  :         return array[index];

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*8]

; 378  :     }

	ret	0
??A?$List@UMediaOutputInfo@@@@QAEAAUMediaOutputInfo@@I@Z ENDP ; List<MediaOutputInfo>::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Num@?$List@UMediaOutputInfo@@@@QBEIXZ
_TEXT	SEGMENT
?Num@?$List@UMediaOutputInfo@@@@QBEIXZ PROC		; List<MediaOutputInfo>::Num, COMDAT
; _this$ = eax

; 37   :     inline unsigned int Num() const     {return num;}

	mov	eax, DWORD PTR [eax+4]
	ret	0
?Num@?$List@UMediaOutputInfo@@@@QBEIXZ ENDP		; List<MediaOutputInfo>::Num
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@UMediaOutputInfo@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@UMediaOutputInfo@@@@QAE@XZ PROC		; List<MediaOutputInfo>::List<MediaOutputInfo>, COMDAT
; _this$ = eax

; 30   :     inline List() : array(NULL), num(0) {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$List@UMediaOutputInfo@@@@QAE@XZ ENDP		; List<MediaOutputInfo>::List<MediaOutputInfo>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$List@E@@QAE@XZ
_TEXT	SEGMENT
??0?$List@E@@QAE@XZ PROC				; List<unsigned char>::List<unsigned char>, COMDAT
; _this$ = eax

; 30   :     inline List() : array(NULL), num(0) {}

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	ret	0
??0?$List@E@@QAE@XZ ENDP				; List<unsigned char>::List<unsigned char>
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.cpp
;	COMDAT ?SetFloat@DeviceSource@@UAEXPB_WM@Z
_TEXT	SEGMENT
_lpName$ = 8						; size = 4
_fValue$ = 12						; size = 4
?SetFloat@DeviceSource@@UAEXPB_WM@Z PROC		; DeviceSource::SetFloat, COMDAT
; _this$ = ecx

; 789  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 790  :     if(!bCapturing)

	cmp	BYTE PTR [esi+192], 0
	je	SHORT $LN1@SetFloat

; 791  :         return;
; 792  : 
; 793  :     if(scmpi(lpName, TEXT("volume")) == 0)

	mov	eax, DWORD PTR _lpName$[ebp]
	push	OFFSET $SG-5639
	push	eax
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN1@SetFloat

; 794  :     {
; 795  :         fNewVol = fValue;

	fld	DWORD PTR _fValue$[ebp]

; 796  :         bRequestVolume = true;

	mov	BYTE PTR [esi+56], 1
	fstp	DWORD PTR [esi+60]
$LN1@SetFloat:
	pop	esi

; 797  :     }
; 798  : }

	pop	ebp
	ret	8
?SetFloat@DeviceSource@@UAEXPB_WM@Z ENDP		; DeviceSource::SetFloat
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetInt@DeviceSource@@UAEXPB_WH@Z
_TEXT	SEGMENT
_lpName$ = 8						; size = 4
_iVal$ = 12						; size = 4
?SetInt@DeviceSource@@UAEXPB_WH@Z PROC			; DeviceSource::SetInt, COMDAT
; _this$ = ecx

; 777  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 778  :     if(bCapturing)

	cmp	BYTE PTR [esi+192], 0
	je	SHORT $LN1@SetInt

; 779  :     {
; 780  :         if(scmpi(lpName, TEXT("timeOffset")) == 0)

	mov	eax, DWORD PTR _lpName$[ebp]
	push	OFFSET $SG-5638
	push	eax
	call	DWORD PTR __imp_?scmpi@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN1@SetInt

; 781  :         {
; 782  :             if(audioOut)

	mov	ecx, DWORD PTR [esi+52]
	test	ecx, ecx
	je	SHORT $LN1@SetInt

; 783  :                 audioOut->SetTimeOffset(iVal);

	mov	edx, DWORD PTR _iVal$[ebp]
	push	edx
	call	DWORD PTR __imp_?SetTimeOffset@AudioSource@@QAEXH@Z
$LN1@SetInt:
	pop	esi

; 784  :         }
; 785  :     }
; 786  : }

	pop	ebp
	ret	8
?SetInt@DeviceSource@@UAEXPB_WH@Z ENDP			; DeviceSource::SetInt
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Render@DeviceSource@@UAEXABUVect2@@0@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_size$ = 12						; size = 4
?Render@DeviceSource@@UAEXABUVect2@@0@Z PROC		; DeviceSource::Render, COMDAT
; _this$ = ecx

; 746  : }

	ret	8
?Render@DeviceSource@@UAEXABUVect2@@0@Z ENDP		; DeviceSource::Render
_TEXT	ENDS
PUBLIC	__real@40a7700000000000
PUBLIC	__real@3f800000
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@40a7700000000000
CONST	SEGMENT
__real@40a7700000000000 DQ 040a7700000000000r	; 3000
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GlobalSourceEnterScene@DeviceSource@@UAEXXZ
_TEXT	SEGMENT
_basicAudio$91329 = -8					; size = 4
_sourceVolume$ = -4					; size = 4
?GlobalSourceEnterScene@DeviceSource@@UAEXXZ PROC	; DeviceSource::GlobalSourceEnterScene, COMDAT
; _this$ = ecx

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 604  :     float sourceVolume = data->GetFloat(TEXT("volume"), 1.0f);

	fld1
	push	esi
	push	ecx
	fstp	DWORD PTR [esp]
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+184]
	push	OFFSET $SG-5629
	call	DWORD PTR __imp_?GetFloat@XElement@@QBEMPB_WM@Z
	fstp	DWORD PTR _sourceVolume$[ebp]

; 605  : 
; 606  :     if(soundOutputType == 1) {

	cmp	DWORD PTR [esi+172], 1
	jne	SHORT $LN4@GlobalSour

; 607  :         audioOut->SetVolume(sourceVolume);

	fld	DWORD PTR _sourceVolume$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+52]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?SetVolume@AudioSource@@QAEXM@Z
$LN4@GlobalSour:

; 608  :     }
; 609  :     if(soundOutputType == 2) {

	cmp	DWORD PTR [esi+172], 2
	jne	SHORT $LN2@GlobalSour

; 610  :         IBasicAudio *basicAudio;
; 611  :         if(SUCCEEDED(audioFilter->QueryInterface(IID_IBasicAudio, (void**)&basicAudio)))

	mov	esi, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax]
	lea	ecx, DWORD PTR _basicAudio$91329[ebp]
	push	ecx
	push	OFFSET _IID_IBasicAudio
	push	esi
	call	edx
	test	eax, eax
	js	SHORT $LN2@GlobalSour

; 612  :         {
; 613  :             long lVol = long((double(sourceVolume)*NEAR_SILENTf)-NEAR_SILENTf);

	fld	DWORD PTR _sourceVolume$[ebp]
	fld	QWORD PTR __real@40a7700000000000
	fmul	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	call	__ftol2_sse

; 614  :             if(lVol <= -NEAR_SILENT)

	cmp	eax, -3000				; fffff448H
	jg	SHORT $LN1@GlobalSour

; 615  :                 lVol = -10000;

	mov	eax, -10000				; ffffd8f0H
$LN1@GlobalSour:

; 616  :             basicAudio->put_Volume(lVol);

	mov	ecx, DWORD PTR _basicAudio$91329[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+28]
	push	ecx
	call	eax

; 617  :             basicAudio->Release();

	mov	eax, DWORD PTR _basicAudio$91329[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
$LN2@GlobalSour:
	pop	esi

; 618  :         }
; 619  :     }
; 620  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GlobalSourceEnterScene@DeviceSource@@UAEXXZ ENDP	; DeviceSource::GlobalSourceEnterScene
_TEXT	ENDS
PUBLIC	__real@00000000
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GlobalSourceLeaveScene@DeviceSource@@UAEXXZ
_TEXT	SEGMENT
_basicAudio$91316 = -4					; size = 4
?GlobalSourceLeaveScene@DeviceSource@@UAEXXZ PROC	; DeviceSource::GlobalSourceLeaveScene, COMDAT
; _this$ = ecx

; 585  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 586  :     if(soundOutputType == 1) {

	cmp	DWORD PTR [esi+172], 1
	jne	SHORT $LN4@GlobalSour@2

; 587  :         audioOut->SetVolume(0.0f);

	fldz
	push	ecx
	mov	ecx, DWORD PTR [esi+52]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?SetVolume@AudioSource@@QAEXM@Z
$LN4@GlobalSour@2:

; 588  :     }
; 589  :     if(soundOutputType == 2) {

	cmp	DWORD PTR [esi+172], 2
	jne	SHORT $LN2@GlobalSour@2

; 590  :         IBasicAudio *basicAudio;
; 591  :         if(SUCCEEDED(audioFilter->QueryInterface(IID_IBasicAudio, (void**)&basicAudio)))

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _basicAudio$91316[ebp]
	push	edx
	push	OFFSET _IID_IBasicAudio
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	test	eax, eax
	js	SHORT $LN2@GlobalSour@2

; 592  :         {
; 593  :             long lVol = long((double(0.0)*NEAR_SILENTf)-NEAR_SILENTf);
; 594  :             if(lVol <= -NEAR_SILENT)
; 595  :                 lVol = -10000;
; 596  :             basicAudio->put_Volume(lVol);

	mov	eax, DWORD PTR _basicAudio$91316[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	-10000					; ffffd8f0H
	push	eax
	call	edx

; 597  :             basicAudio->Release();

	mov	eax, DWORD PTR _basicAudio$91316[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
$LN2@GlobalSour@2:
	pop	esi

; 598  :         }
; 599  :     }
; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GlobalSourceLeaveScene@DeviceSource@@UAEXXZ ENDP	; DeviceSource::GlobalSourceLeaveScene
_TEXT	ENDS
PUBLIC	?Start@DeviceSource@@AAEXXZ			; DeviceSource::Start
; Function compile flags: /Ogtp
;	COMDAT ?Start@DeviceSource@@AAEXXZ
_TEXT	SEGMENT
?Start@DeviceSource@@AAEXXZ PROC			; DeviceSource::Start, COMDAT
; _this$ = esi

; 551  :     if(bCapturing || !control)

	cmp	BYTE PTR [esi+192], 0
	jne	SHORT $LN2@Start
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN2@Start

; 552  :         return;
; 553  : 
; 554  :     HRESULT err;
; 555  :     if(FAILED(err = control->Run()))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx
	test	eax, eax
	jns	SHORT $LN1@Start

; 556  :     {
; 557  :         AppWarning(TEXT("DShowAudioPlugin: control->Run failed, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5628
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 562  : }

	ret	0
$LN1@Start:

; 558  :         return;
; 559  :     }
; 560  : 
; 561  :     bCapturing = true;

	mov	BYTE PTR [esi+192], 1
$LN2@Start:

; 562  : }

	ret	0
?Start@DeviceSource@@AAEXXZ ENDP			; DeviceSource::Start
_TEXT	ENDS
PUBLIC	__real@4f800000
;	COMDAT __real@4f800000
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\xmath.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.h
CONST	ENDS
;	COMDAT ?GetSize@DeviceSource@@UBE?AUVect2@@XZ
_TEXT	SEGMENT
tv139 = -4						; size = 4
tv137 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetSize@DeviceSource@@UBE?AUVect2@@XZ PROC		; DeviceSource::GetSize, COMDAT
; _this$ = ecx

; 223  :     Vect2 GetSize() const {return Vect2(float(renderCX), float(renderCY));}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	eax, DWORD PTR [ecx+136]
	fild	DWORD PTR [ecx+136]
	test	eax, eax
	jns	SHORT $LN5@GetSize
	fadd	DWORD PTR __real@4f800000
$LN5@GetSize:
	mov	ecx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	fstp	DWORD PTR [eax]
	fild	DWORD PTR tv137[ebp]
	test	ecx, ecx
	jns	SHORT $LN6@GetSize
	fadd	DWORD PTR __real@4f800000
$LN6@GetSize:
	fstp	DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetSize@DeviceSource@@UBE?AUVect2@@XZ ENDP		; DeviceSource::GetSize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0SampleData@@QAE@XZ
_TEXT	SEGMENT
??0SampleData@@QAE@XZ PROC				; SampleData::SampleData, COMDAT
; _this$ = eax

; 48   :     inline SampleData() {refs = 1;}

	mov	DWORD PTR [eax+24], 1
	ret	0
??0SampleData@@QAE@XZ ENDP				; SampleData::SampleData
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\mediainfostuff.h
_TEXT	ENDS
;	COMDAT ?FreeData@MediaOutputInfo@@QAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?FreeData@MediaOutputInfo@@QAEXXZ PROC			; MediaOutputInfo::FreeData, COMDAT

; 105  :     {

	push	ebp
	mov	ebp, esp

; 106  :         FreeMediaType(*mediaType);

	mov	eax, DWORD PTR _this$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __imp__CoTaskMemFree@4
	push	esi
	mov	esi, DWORD PTR [eax+4]
	cmp	DWORD PTR [esi+64], 0
	je	SHORT $LN4@FreeData
	mov	ecx, DWORD PTR [esi+68]
	push	ecx
	call	ebx
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
$LN4@FreeData:
	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN3@FreeData
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR [esi+60], 0
$LN3@FreeData:

; 107  :         CoTaskMemFree(mediaType);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	ebx
	pop	esi
	pop	ebx

; 108  :     }

	pop	ebp
	ret	4
?FreeData@MediaOutputInfo@@QAEXXZ ENDP			; MediaOutputInfo::FreeData
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?DeleteMediaType@@YAXPAU_AMMediaType@@@Z
_TEXT	SEGMENT
?DeleteMediaType@@YAXPAU_AMMediaType@@@Z PROC		; DeleteMediaType, COMDAT
; _pmt$ = esi

; 28   :     if(pmt != NULL)

	test	esi, esi
	je	SHORT $LN1@DeleteMedi

; 29   :     {
; 30   :         FreeMediaType(*pmt);

	cmp	DWORD PTR [esi+64], 0
	push	ebx
	mov	ebx, DWORD PTR __imp__CoTaskMemFree@4
	je	SHORT $LN5@DeleteMedi
	mov	eax, DWORD PTR [esi+68]
	push	eax
	call	ebx
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
$LN5@DeleteMedi:
	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN4@DeleteMedi
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+60], 0
$LN4@DeleteMedi:

; 31   :         CoTaskMemFree(pmt);

	push	esi
	call	ebx
	pop	ebx
$LN1@DeleteMedi:

; 32   :     }
; 33   : }

	ret	0
?DeleteMediaType@@YAXPAU_AMMediaType@@@Z ENDP		; DeleteMediaType
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\graphicssystem.h
_TEXT	ENDS
;	COMDAT ?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_colorFormat$ = 16					; size = 4
_lpData$ = 20						; size = 4
?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z PROC ; CreateTexture, COMDAT

; 545  :     {return GS->CreateTexture(width, height, colorFormat, lpData, bGenMipMaps, bStatic);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _lpData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+24]
	push	0
	push	0
	push	eax
	mov	eax, DWORD PTR _colorFormat$[ebp]
	push	eax
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	edx
	pop	ebp
	ret	0
?CreateTexture@@YAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ENDP ; CreateTexture
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\inline.h
_TEXT	ENDS
;	COMDAT ?mcpyrev@@YGXPAXPBXI@Z
_TEXT	SEGMENT
_pDest$ = 8						; size = 4
?mcpyrev@@YGXPAXPBXI@Z PROC				; mcpyrev, COMDAT
; _pSrc$ = edx
; _iLen$ = eax

; 283  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, eax

; 284  :     assert(pDest);
; 285  :     assert(pSrc);
; 286  : 
; 287  :     register size_t iLenMod4 = iLen&3;

	mov	ecx, esi

; 288  :     register size_t iLenDiv4 = iLen>>2;
; 289  : 
; 290  :     register BYTE *srcB = (BYTE*)pSrc, *destB = (BYTE*)pDest;
; 291  :     register DWORD *srcDW = (DWORD*)(srcB+iLen), *destDW = (DWORD*)(destB+iLen);

	add	edx, esi
	add	esi, DWORD PTR _pDest$[ebp]
	shr	eax, 2
	and	ecx, 3
	push	edi

; 292  :     while(iLenDiv4--)

	test	eax, eax
	je	SHORT $LN9@mcpyrev
	npad	8
$LL4@mcpyrev:

; 293  :         *(--destDW) = *(--srcDW);

	mov	edi, DWORD PTR [edx-4]
	sub	edx, 4
	sub	esi, 4
	dec	eax
	mov	DWORD PTR [esi], edi
	jne	SHORT $LL4@mcpyrev
$LN9@mcpyrev:

; 294  : 
; 295  :     srcB = (BYTE*)srcDW;

	mov	eax, edx

; 296  :     destB = (BYTE*)destDW;
; 297  :     while(iLenMod4--)

	test	ecx, ecx
	je	SHORT $LN11@mcpyrev
	sub	esi, edx
$LL2@mcpyrev:

; 298  :         *(--destB) = *(--srcB);

	mov	dl, BYTE PTR [eax-1]
	dec	eax
	dec	ecx
	mov	BYTE PTR [esi+eax], dl
	jne	SHORT $LL2@mcpyrev
$LN11@mcpyrev:
	pop	edi
	pop	esi

; 299  : }

	pop	ebp
	ret	4
?mcpyrev@@YGXPAXPBXI@Z ENDP				; mcpyrev
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?msetd@@YGXPAXKI@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?msetd@@YGXPAXKI@Z PROC					; msetd, COMDAT
; _pDest$ = ecx
; _iLen$ = eax

; 241  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 242  :     assert(pDest);
; 243  : 
; 244  :     register size_t iLenMod4 = iLen&3;

	mov	edx, eax

; 245  :     register size_t iLenDiv4 = iLen>>2;

	shr	eax, 2
	push	esi
	mov	esi, eax
	and	edx, 3
	mov	ebx, ecx

; 246  : 
; 247  :     register DWORD *destDW = (DWORD*)pDest;
; 248  :     while(iLenDiv4--)

	test	esi, esi
	je	SHORT $LN4@msetd

; 242  :     assert(pDest);
; 243  : 
; 244  :     register size_t iLenMod4 = iLen&3;

	mov	eax, DWORD PTR _val$[ebp]
	push	edi
	mov	edi, ebx
	mov	ecx, esi
	rep stosd

; 246  : 
; 247  :     register DWORD *destDW = (DWORD*)pDest;
; 248  :     while(iLenDiv4--)

	lea	ebx, DWORD PTR [ebx+esi*4]
	pop	edi
$LN4@msetd:

; 252  :     register BYTE *pVal = (BYTE*)&val;
; 253  :     while(iLenMod4--)

	test	edx, edx
	je	SHORT $LN2@msetd

; 249  :         *(destDW++) = val;
; 250  : 
; 251  :     register BYTE *destB = (BYTE*)destDW;

	push	edx
	lea	eax, DWORD PTR _val$[ebp]
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@msetd:
	pop	esi
	pop	ebx

; 254  :         *(destB++) = *(pVal++);
; 255  : }

	pop	ebp
	ret	4
?msetd@@YGXPAXKI@Z ENDP					; msetd
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UMediaOutputInfo@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$List@UMediaOutputInfo@@@@QAEXXZ PROC		; List<MediaOutputInfo>::Clear, COMDAT
; _this$ = esi

; 330  :         if(array)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@Clear@3

; 331  :         {
; 332  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 333  :                 CrashError(TEXT("what the.."));*/
; 334  :             Free(array);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 335  :             array = NULL;

	mov	DWORD PTR [esi], 0

; 336  :             num = 0;

	mov	DWORD PTR [esi+4], 0
$LN1@Clear@3:

; 337  :         }
; 338  :     }

	ret	0
?Clear@?$List@UMediaOutputInfo@@@@QAEXXZ ENDP		; List<MediaOutputInfo>::Clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@UMediaOutputInfo@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@UMediaOutputInfo@@@@QAE@XZ PROC		; List<MediaOutputInfo>::~List<MediaOutputInfo>, COMDAT
; _this$ = esi

; 33   :         Clear();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@List@2
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
$LN3@List@2:

; 34   :     }

	ret	0
??1?$List@UMediaOutputInfo@@@@QAE@XZ ENDP		; List<MediaOutputInfo>::~List<MediaOutputInfo>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Insert@?$List@PAUSampleData@@@@QAEXIABQAUSampleData@@@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?Insert@?$List@PAUSampleData@@@@QAEXIABQAUSampleData@@@Z PROC ; List<SampleData *>::Insert, COMDAT
; _this$ = esi
; _val$ = eax

; 59   :     {

	push	ebp
	mov	ebp, esp

; 60   :         assert(index <= num);
; 61   :         if(index > num) return;

	mov	ecx, DWORD PTR _index$[ebp]
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, eax
	ja	$LN8@Insert

; 62   : 
; 63   :         if(!num && !index)

	test	eax, eax
	jne	SHORT $LN2@Insert
	test	ecx, ecx
	jne	SHORT $LN2@Insert

; 64   :         {
; 65   :             Add(val);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	DWORD PTR [esi+4], 1
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+8]
	push	4
	push	eax
	call	edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax+ecx*4-4], edx
	pop	edi

; 80   :     }

	pop	ebp
	ret	4
$LN2@Insert:

; 66   :             return;
; 67   :         }
; 68   : 
; 69   :         //this makes it safe to insert an item already in the list
; 70   :         T *temp = (T*)Allocate(sizeof(T));

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	ebx
	push	4
	call	eax

; 71   :         mcpy(temp, &val, sizeof(T));

	mov	ecx, DWORD PTR [edi]

; 72   : 
; 73   :         UINT moveCount = num-index;
; 74   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ebx, eax
	mov	DWORD PTR [ebx], ecx
	mov	eax, DWORD PTR [esi+4]
	mov	edi, eax
	inc	eax
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	add	eax, eax
	add	eax, eax
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	edx
	sub	edi, DWORD PTR _index$[ebp]
	mov	DWORD PTR [esi], eax

; 75   :         if(moveCount)

	je	SHORT $LN1@Insert

; 76   :             mcpyrev(array+(index+1), array+index, moveCount*sizeof(T));

	mov	ecx, DWORD PTR _index$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [edx+4]
	lea	eax, DWORD PTR [edi*4]
	push	ecx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev
$LN1@Insert:

; 77   :         mcpy(&array[index], temp, sizeof(T));

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 78   : 
; 79   :         Free(temp);

	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	ebx
	call	edx
	pop	ebx
$LN8@Insert:
	pop	edi

; 80   :     }

	pop	ebp
	ret	4
?Insert@?$List@PAUSampleData@@@@QAEXIABQAUSampleData@@@Z ENDP ; List<SampleData *>::Insert
_TEXT	ENDS
PUBLIC	?GetSampleInsertIndex@DeviceSource@@AAEI_J@Z	; DeviceSource::GetSampleInsertIndex
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.cpp
;	COMDAT ?GetSampleInsertIndex@DeviceSource@@AAEI_J@Z
_TEXT	SEGMENT
_timestamp$ = 8						; size = 8
?GetSampleInsertIndex@DeviceSource@@AAEI_J@Z PROC	; DeviceSource::GetSampleInsertIndex, COMDAT
; _this$ = edi

; 734  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 735  :     UINT index;
; 736  :     for (index=0; index<samples.Num(); index++) {

	xor	esi, esi
	cmp	esi, DWORD PTR [edi+228]
	jae	SHORT $LN2@GetSampleI

; 737  :         if (samples[index]->timestamp > timestamp)

	mov	ebx, DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN9@GetSampleI:

; 735  :     UINT index;
; 736  :     for (index=0; index<samples.Num(); index++) {

	mov	eax, DWORD PTR [edi+224]
	lea	eax, DWORD PTR [eax+esi*4]

; 737  :         if (samples[index]->timestamp > timestamp)

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _timestamp$[ebp+4]
	jg	SHORT $LN2@GetSampleI
	jl	SHORT $LN15@GetSampleI
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR _timestamp$[ebp]
	ja	SHORT $LN2@GetSampleI
$LN15@GetSampleI:

; 735  :     UINT index;
; 736  :     for (index=0; index<samples.Num(); index++) {

	inc	esi
	cmp	esi, DWORD PTR [edi+228]
	jb	SHORT $LN9@GetSampleI
$LN2@GetSampleI:

; 738  :             return index;
; 739  :     }
; 740  : 
; 741  :     return index;

	mov	eax, esi
	pop	esi
	pop	ebx

; 742  : }

	pop	ebp
	ret	8
?GetSampleInsertIndex@DeviceSource@@AAEI_J@Z ENDP	; DeviceSource::GetSampleInsertIndex
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?BeginScene@DeviceSource@@UAEXXZ
_TEXT	SEGMENT
?BeginScene@DeviceSource@@UAEXXZ PROC			; DeviceSource::BeginScene, COMDAT
; _this$ = ecx

; 575  : {

	push	esi
	mov	esi, ecx

; 576  :     Start();

	cmp	BYTE PTR [esi+192], 0
	jne	SHORT $LN4@BeginScene
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@BeginScene
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx
	test	eax, eax
	jns	SHORT $LN3@BeginScene
	push	eax
	push	OFFSET $SG-5628
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8
	pop	esi

; 577  : }

	ret	0

; 576  :     Start();

$LN3@BeginScene:
	mov	BYTE PTR [esi+192], 1
$LN4@BeginScene:
	pop	esi

; 577  : }

	ret	0
?BeginScene@DeviceSource@@UAEXXZ ENDP			; DeviceSource::BeginScene
_TEXT	ENDS
PUBLIC	?UnloadFilters@DeviceSource@@AAEXXZ		; DeviceSource::UnloadFilters
; Function compile flags: /Ogtp
;	COMDAT ?UnloadFilters@DeviceSource@@AAEXXZ
_TEXT	SEGMENT
_numThreads$ = -4					; size = 4
?UnloadFilters@DeviceSource@@AAEXXZ PROC		; DeviceSource::UnloadFilters, COMDAT
; _this$ = esi

; 476  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 477  :     if(texture)

	mov	ecx, DWORD PTR [esi+180]
	push	ebx
	xor	ebx, ebx
	cmp	ecx, ebx
	je	SHORT $LN32@UnloadFilt

; 478  :     {
; 479  :         delete texture;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 480  :         texture = NULL;

	mov	DWORD PTR [esi+180], ebx
$LN32@UnloadFilt:

; 481  :     }
; 482  : 
; 483  :     int numThreads = MAX(OSGetTotalCores()-2, 1);

	push	edi
	mov	edi, DWORD PTR __imp_?OSGetTotalCores@@YGHXZ
	call	edi
	sub	eax, 2
	cmp	eax, 1
	jle	SHORT $LN22@UnloadFilt
	call	edi
	sub	eax, 2
	mov	DWORD PTR _numThreads$[ebp], eax
	jmp	SHORT $LN23@UnloadFilt
$LN22@UnloadFilt:
	mov	DWORD PTR _numThreads$[ebp], 1
$LN23@UnloadFilt:

; 484  :     for(int i=0; i<numThreads; i++)

	cmp	DWORD PTR _numThreads$[ebp], ebx
	jle	$LN14@UnloadFilt
	xor	edi, edi
	npad	4
$LL16@UnloadFilt:

; 485  :     {
; 486  :         if(hConvertThreads[i])

	mov	eax, DWORD PTR [esi+244]
	cmp	DWORD PTR [eax+ebx*4], 0
	je	SHORT $LN13@UnloadFilt

; 487  :         {
; 488  :             convertData[i].bKillThread = true;

	mov	ecx, DWORD PTR [esi+240]
	mov	BYTE PTR [edi+ecx+20], 1

; 489  :             SetEvent(convertData[i].hSignalConvert);

	mov	edx, DWORD PTR [esi+240]
	mov	eax, DWORD PTR [edi+edx+12]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 490  : 
; 491  :             OSTerminateThread(hConvertThreads[i], 10000);

	mov	ecx, DWORD PTR [esi+244]
	mov	edx, DWORD PTR [ecx+ebx*4]
	push	10000					; 00002710H
	push	edx
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z

; 492  :             hConvertThreads[i] = NULL;

	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [eax+ebx*4], 0
$LN13@UnloadFilt:

; 493  :         }
; 494  : 
; 495  :         convertData[i].bKillThread = false;

	mov	ecx, DWORD PTR [esi+240]
	mov	BYTE PTR [edi+ecx+20], 0

; 496  : 
; 497  :         if(convertData[i].hSignalConvert)

	mov	edx, DWORD PTR [esi+240]
	mov	eax, DWORD PTR [edi+edx+12]
	test	eax, eax
	je	SHORT $LN12@UnloadFilt

; 498  :         {
; 499  :             CloseHandle(convertData[i].hSignalConvert);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 500  :             convertData[i].hSignalConvert = NULL;

	mov	eax, DWORD PTR [esi+240]
	mov	DWORD PTR [edi+eax+12], 0
$LN12@UnloadFilt:

; 501  :         }
; 502  : 
; 503  :         if(convertData[i].hSignalComplete)

	mov	ecx, DWORD PTR [esi+240]
	mov	eax, DWORD PTR [edi+ecx+16]
	test	eax, eax
	je	SHORT $LN15@UnloadFilt

; 504  :         {
; 505  :             CloseHandle(convertData[i].hSignalComplete);

	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 506  :             convertData[i].hSignalComplete = NULL;

	mov	edx, DWORD PTR [esi+240]
	mov	DWORD PTR [edi+edx+16], 0
$LN15@UnloadFilt:

; 484  :     for(int i=0; i<numThreads; i++)

	inc	ebx
	add	edi, 44					; 0000002cH
	cmp	ebx, DWORD PTR _numThreads$[ebp]
	jl	$LL16@UnloadFilt
	xor	ebx, ebx
$LN14@UnloadFilt:

; 507  :         }
; 508  :     }
; 509  : 
; 510  :     if(bFiltersLoaded)

	cmp	BYTE PTR [esi+193], 0
	je	$LN10@UnloadFilt

; 511  :     {
; 512  :         graph->RemoveFilter(captureFilter);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax

; 513  :         graph->RemoveFilter(deviceFilter);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax

; 514  :         graph->RemoveFilter(audioDeviceFilter);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax

; 515  : 
; 516  :         if(audioFilter)

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, ebx
	je	SHORT $LN9@UnloadFilt

; 517  :             graph->RemoveFilter(audioFilter);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+16]
	push	ecx
	call	eax
$LN9@UnloadFilt:

; 518  : 
; 519  :         SafeReleaseLogRef(captureFilter);

	mov	eax, DWORD PTR [esi+24]
	mov	edi, DWORD PTR __imp_?OSDebugOut@@YAXPB_WZZ
	cmp	eax, ebx
	je	SHORT $LN8@UnloadFilt
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	push	eax
	push	OFFSET $SG-5620
	push	OFFSET $SG-5621
	call	edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+24], ebx
$LN8@UnloadFilt:

; 520  :         SafeReleaseLogRef(deviceFilter);

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ebx
	je	SHORT $LN7@UnloadFilt
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	push	eax
	push	OFFSET $SG-5622
	push	OFFSET $SG-5623
	call	edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+16], ebx
$LN7@UnloadFilt:

; 521  :         SafeReleaseLogRef(audioDeviceFilter);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	je	SHORT $LN6@UnloadFilt
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	push	eax
	push	OFFSET $SG-5624
	push	OFFSET $SG-5625
	call	edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+20], ebx
$LN6@UnloadFilt:

; 522  :         SafeReleaseLogRef(audioFilter);

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, ebx
	je	SHORT $LN5@UnloadFilt
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	push	eax
	push	OFFSET $SG-5626
	push	OFFSET $SG-5627
	call	edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+28], ebx
$LN5@UnloadFilt:

; 523  : 
; 524  :         bFiltersLoaded = false;

	mov	BYTE PTR [esi+193], 0
$LN10@UnloadFilt:

; 525  :     }
; 526  : 
; 527  :     if(audioOut)

	mov	eax, DWORD PTR [esi+52]
	pop	edi
	cmp	eax, ebx
	je	SHORT $LN4@UnloadFilt

; 528  :     {
; 529  :         API->RemoveAudioSource(audioOut);

	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+128]
	call	eax

; 530  :         delete audioOut;

	mov	ecx, DWORD PTR [esi+52]
	cmp	ecx, ebx
	je	SHORT $LN24@UnloadFilt
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	1
	call	eax
$LN24@UnloadFilt:

; 531  :         audioOut = NULL;

	mov	DWORD PTR [esi+52], ebx
$LN4@UnloadFilt:

; 532  :     }
; 533  : 
; 534  :     if(colorConvertShader)

	mov	ecx, DWORD PTR [esi+196]
	cmp	ecx, ebx
	je	SHORT $LN3@UnloadFilt

; 535  :     {
; 536  :         delete colorConvertShader;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	push	1
	call	eax

; 537  :         colorConvertShader = NULL;

	mov	DWORD PTR [esi+196], ebx
$LN3@UnloadFilt:

; 538  :     }
; 539  : 
; 540  :     if(lpImageBuffer)

	mov	eax, DWORD PTR [esi+236]
	cmp	eax, ebx
	je	SHORT $LN2@UnloadFilt

; 541  :     {
; 542  :         Free(lpImageBuffer);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 543  :         lpImageBuffer = NULL;

	mov	DWORD PTR [esi+236], ebx
$LN2@UnloadFilt:

; 544  :     }
; 545  : 
; 546  :     SafeRelease(control);

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, ebx
	je	SHORT $LN1@UnloadFilt
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+12], ebx
$LN1@UnloadFilt:
	pop	ebx

; 547  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UnloadFilters@DeviceSource@@AAEXXZ ENDP		; DeviceSource::UnloadFilters
_TEXT	ENDS
PUBLIC	?Init@DeviceSource@@QAE_NPAVXElement@@@Z	; DeviceSource::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@DeviceSource@@QAE_NPAVXElement@@@Z
_TEXT	SEGMENT
_iLenDiv4$105408 = -8					; size = 4
_destDW$105422 = -4					; size = 4
_destDW$105409 = -4					; size = 4
_data$ = 8						; size = 4
?Init@DeviceSource@@QAE_NPAVXElement@@@Z PROC		; DeviceSource::Init, COMDAT
; _this$ = ebx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi

; 30   :     HRESULT err;
; 31   :     err = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, (REFIID)IID_IFilterGraph, (void**)&graph);

	lea	edi, DWORD PTR [ebx+4]
	push	edi
	push	OFFSET _IID_IFilterGraph
	push	1
	push	0
	push	OFFSET _CLSID_FilterGraph
	call	DWORD PTR __imp__CoCreateInstance@20

; 32   :     if(FAILED(err))

	test	eax, eax
	jns	SHORT $LN3@Init

; 33   :     {
; 34   :         AppWarning(TEXT("DShowAudioPlugin: Failed to build IGraphBuilder, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5575
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 35   :         return false;

	xor	al, al
	pop	edi

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@Init:
	push	esi

; 36   :     }
; 37   : 
; 38   :     err = CoCreateInstance(CLSID_CaptureGraphBuilder2, NULL, CLSCTX_INPROC_SERVER, (REFIID)IID_ICaptureGraphBuilder2, (void**)&capture);

	lea	esi, DWORD PTR [ebx+8]
	push	esi
	push	OFFSET _IID_ICaptureGraphBuilder2
	push	1
	push	0
	push	OFFSET _CLSID_CaptureGraphBuilder2
	call	DWORD PTR __imp__CoCreateInstance@20

; 39   :     if(FAILED(err))

	test	eax, eax
	jns	SHORT $LN2@Init

; 40   :     {
; 41   :         AppWarning(TEXT("DShowAudioPlugin: Failed to build ICaptureGraphBuilder2, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5576
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8
	pop	esi

; 42   :         return false;

	xor	al, al
	pop	edi

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Init:

; 43   :     }
; 44   : 
; 45   :     hSampleMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	DWORD PTR [ebx+208], eax

; 46   :     if(!hSampleMutex)

	test	eax, eax
	jne	SHORT $LN1@Init

; 47   :     {
; 48   :         AppWarning(TEXT("DShowAudioPlugin: could not create sample mutex"));

	push	OFFSET $SG-5577
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4
	pop	esi

; 49   :         return false;

	xor	al, al
	pop	edi

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN1@Init:

; 50   :     }
; 51   : 
; 52   :     capture->SetFiltergraph(graph);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax

; 53   : 
; 54   :     int numThreads = MAX(OSGetTotalCores()-2, 1);

	mov	esi, DWORD PTR __imp_?OSGetTotalCores@@YGHXZ
	call	esi
	sub	eax, 2
	cmp	eax, 1
	jle	SHORT $LN6@Init
	call	esi
	lea	esi, DWORD PTR [eax-2]
	jmp	SHORT $LN7@Init
$LN6@Init:
	mov	esi, 1
$LN7@Init:

; 55   :     hConvertThreads = (HANDLE*)Allocate(sizeof(HANDLE)*numThreads);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [esi*4]
	push	edi
	call	eax

; 56   :     convertData = (ConvertData*)Allocate(sizeof(ConvertData)*numThreads);

	imul	esi, 44					; 0000002cH
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	DWORD PTR [ebx+244], eax
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 57   : 
; 58   :     zero(hConvertThreads, sizeof(HANDLE)*numThreads);

	mov	edx, edi
	shr	edi, 2
	mov	ecx, edi
	mov	edi, DWORD PTR [ebx+244]
	and	edx, 3
	mov	DWORD PTR [ebx+240], eax
	mov	DWORD PTR _iLenDiv4$105408[ebp], ecx
	mov	DWORD PTR _destDW$105409[ebp], edi
	test	ecx, ecx
	je	SHORT $LN11@Init

; 55   :     hConvertThreads = (HANDLE*)Allocate(sizeof(HANDLE)*numThreads);

	xor	eax, eax
	rep stosd

; 57   : 
; 58   :     zero(hConvertThreads, sizeof(HANDLE)*numThreads);

	mov	ecx, DWORD PTR _destDW$105409[ebp]
	mov	eax, DWORD PTR _iLenDiv4$105408[ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _destDW$105409[ebp], ecx
	mov	edi, ecx
$LN11@Init:
	test	edx, edx
	je	SHORT $LN9@Init
	push	edx
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@Init:

; 59   :     zero(convertData, sizeof(ConvertData)*numThreads);

	mov	edi, DWORD PTR [ebx+240]
	mov	edx, esi
	shr	esi, 2
	and	edx, 3
	mov	DWORD PTR _destDW$105422[ebp], edi
	test	esi, esi
	je	SHORT $LN17@Init
	xor	eax, eax
	mov	ecx, esi
	rep stosd
	mov	eax, DWORD PTR _destDW$105422[ebp]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR _destDW$105422[ebp], ecx
	mov	edi, ecx
$LN17@Init:
	test	edx, edx
	je	SHORT $LN15@Init
	push	edx
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
$LN15@Init:

; 60   : 
; 61   :     this->data = data;

	mov	edx, DWORD PTR _data$[ebp]

; 62   :     UpdateSettings();

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+184], edx
	mov	edx, DWORD PTR [eax+20]
	mov	ecx, ebx
	call	edx

; 63   : 
; 64   :     //if(!bFiltersLoaded)
; 65   :     //    return false;
; 66   : 
; 67   :     Log(TEXT("Using directshow audio input"));

	push	OFFSET $SG-5578
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
	pop	esi

; 68   : 
; 69   :     return true;

	mov	al, 1
	pop	edi

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@DeviceSource@@QAE_NPAVXElement@@@Z ENDP		; DeviceSource::Init
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@PAUSampleData@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@PAUSampleData@@@@QAE@XZ PROC			; List<SampleData *>::~List<SampleData *>, COMDAT
; _this$ = esi

; 33   :         Clear();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@List@4
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
$LN3@List@4:

; 34   :     }

	ret	0
??1?$List@PAUSampleData@@@@QAE@XZ ENDP			; List<SampleData *>::~List<SampleData *>
_TEXT	ENDS
PUBLIC	?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z ; DeviceSource::ReceiveMediaSample
;	COMDAT xdata$x
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.h
xdata$x	SEGMENT
__unwindtable$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z$0
__ehfuncinfo$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.cpp
xdata$x	ENDS
;	COMDAT ?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z
_TEXT	SEGMENT
_stopTime$91353 = -32					; size = 8
$T106076 = -24						; size = 4
_pointer$91342 = -20					; size = 4
_data$91345 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_bAudio$ = 12						; size = 1
?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z PROC ; DeviceSource::ReceiveMediaSample, COMDAT
; _sample$ = ecx

; 623  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _this$[ebp]

; 624  :     if (!sample)

	test	ebx, ebx
	je	$LN7@ReceiveMed

; 625  :         return;
; 626  : 
; 627  :     if (bCapturing) {

	cmp	BYTE PTR [edi+192], 0
	je	$LN7@ReceiveMed

; 628  :         BYTE *pointer;
; 629  : 
; 630  :         if (SUCCEEDED(sample->GetPointer(&pointer))) {

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+12]
	lea	ecx, DWORD PTR _pointer$91342[ebp]
	push	ecx
	push	ebx
	call	edx
	test	eax, eax
	js	$LN7@ReceiveMed

; 631  :             SampleData *data = NULL;

	xor	esi, esi

; 632  :             
; 633  :             if (bUseBuffering || !bAudio) {

	cmp	BYTE PTR [edi+200], 0
	mov	DWORD PTR _data$91345[ebp], esi
	jne	SHORT $LN5@ReceiveMed
	cmp	BYTE PTR _bAudio$[ebp], 0
	jne	$LN6@ReceiveMed
$LN5@ReceiveMed:

; 634  :                 data = new SampleData;

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	32					; 00000020H
	call	eax
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	xor	esi, esi
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR $T106076[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], esi
	cmp	eax, esi
	je	SHORT $LN12@ReceiveMed
	mov	DWORD PTR [eax+24], 1
	mov	esi, eax
$LN12@ReceiveMed:
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 635  :                 data->bAudio = bAudio;

	mov	cl, BYTE PTR _bAudio$[ebp]
	mov	BYTE PTR [esi+8], cl

; 636  :                 data->dataLength = sample->GetActualDataLength();

	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+44]
	push	ebx
	mov	DWORD PTR _data$91345[ebp], esi
	call	eax

; 637  :                 data->lpData = (LPBYTE)Allocate(data->dataLength);//pointer; //

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR [esi], eax

; 638  :                 /*data->sample = sample;
; 639  :                 sample->AddRef();*/
; 640  : 
; 641  :                 memcpy(data->lpData, pointer, data->dataLength);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _pointer$91342[ebp]
	push	ecx
	push	edx
	push	eax
	call	_memcpy

; 642  : 
; 643  :                 LONGLONG stopTime;
; 644  :                 sample->GetTime(&data->timestamp, &stopTime);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+20]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _stopTime$91353[ebp]
	push	ecx
	lea	edx, DWORD PTR [esi+16]
	push	edx
	push	ebx
	call	eax
	mov	edi, DWORD PTR _this$[ebp]
$LN6@ReceiveMed:

; 645  :             }
; 646  : 
; 647  :             //Log(TEXT("timestamp: %lld, bAudio - %s"), data->timestamp, bAudio ? TEXT("true") : TEXT("false"));
; 648  : 
; 649  :             OSEnterMutex(hSampleMutex);

	mov	ecx, DWORD PTR [edi+208]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 650  : 
; 651  :             if (bUseBuffering) {

	cmp	BYTE PTR [edi+200], 0
	je	SHORT $LN4@ReceiveMed

; 652  :                 UINT id = GetSampleInsertIndex(data->timestamp);

	mov	edx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR [esi+16]
	push	edx
	push	eax
	call	?GetSampleInsertIndex@DeviceSource@@AAEI_J@Z ; DeviceSource::GetSampleInsertIndex

; 653  :                 samples.Insert(id, data);

	push	eax
	lea	esi, DWORD PTR [edi+224]
	lea	eax, DWORD PTR _data$91345[ebp]
	call	?Insert@?$List@PAUSampleData@@@@QAEXIABQAUSampleData@@@Z ; List<SampleData *>::Insert
	jmp	SHORT $LN1@ReceiveMed
$LN4@ReceiveMed:

; 654  :             } else if (bAudio) {

	cmp	BYTE PTR _bAudio$[ebp], 0
	je	SHORT $LN1@ReceiveMed

; 655  :                 if (audioOut)

	cmp	DWORD PTR [edi+52], 0
	je	SHORT $LN1@ReceiveMed

; 656  :                     audioOut->ReceiveAudio(pointer, sample->GetActualDataLength());

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ecx+44]
	push	ebx
	call	edx
	mov	ecx, DWORD PTR _pointer$91342[ebp]
	mov	edx, DWORD PTR [edi+52]
	push	ecx
	push	edx
	mov	ebx, eax
	call	?ReceiveAudio@DeviceAudioSource@@QAEXPAEI@Z ; DeviceAudioSource::ReceiveAudio
$LN1@ReceiveMed:

; 657  :             }
; 658  : 
; 659  :             OSLeaveMutex(hSampleMutex);

	mov	eax, DWORD PTR [edi+208]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
$LN7@ReceiveMed:

; 660  :         }
; 661  :     }
; 662  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z$0:
	mov	eax, DWORD PTR $T106076[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z ENDP ; DeviceSource::ReceiveMediaSample
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DeviceAudioSource@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DeviceAudioSource@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0DeviceAudioSource@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0DeviceAudioSource@@QAE@XZ$2
__ehfuncinfo$??0DeviceAudioSource@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0DeviceAudioSource@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0DeviceAudioSource@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0DeviceAudioSource@@QAE@XZ PROC			; DeviceAudioSource::DeviceAudioSource, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DeviceAudioSource@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, esi
	call	DWORD PTR __imp_??0AudioSource@@QAE@XZ
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	mov	DWORD PTR [esi], OFFSET ??_7DeviceAudioSource@@6B@
	mov	DWORD PTR [esi+144], eax
	mov	DWORD PTR [esi+148], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [esi+152], eax
	mov	DWORD PTR [esi+156], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DeviceAudioSource@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1AudioSource@@UAE@XZ
__unwindfunclet$??0DeviceAudioSource@@QAE@XZ$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 144				; 00000090H
	jmp	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
__unwindfunclet$??0DeviceAudioSource@@QAE@XZ$2:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 152				; 00000098H
	jmp	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
__ehhandler$??0DeviceAudioSource@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DeviceAudioSource@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DeviceAudioSource@@QAE@XZ ENDP			; DeviceAudioSource::DeviceAudioSource
PUBLIC	?SetAudioInfo@DeviceSource@@AAEXPAU_AMMediaType@@AAU_GUID@@@Z ; DeviceSource::SetAudioInfo
; Function compile flags: /Ogtp
;	COMDAT ?SetAudioInfo@DeviceSource@@AAEXPAU_AMMediaType@@AAU_GUID@@@Z
_TEXT	SEGMENT
?SetAudioInfo@DeviceSource@@AAEXPAU_AMMediaType@@AAU_GUID@@@Z PROC ; DeviceSource::SetAudioInfo, COMDAT
; _this$ = ecx
; _audioMediaType$ = esi
; _expectedAudioType$ = eax

; 96   : {

	push	ebx
	push	edi
	mov	edi, ecx

; 97   :     expectedAudioType = audioMediaType->subtype;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [eax+12], edx

; 98   : 
; 99   :     if(audioMediaType->formattype == FORMAT_WaveFormatEx)

	lea	edx, DWORD PTR [esi+44]
	mov	ecx, OFFSET _FORMAT_WaveFormatEx
	call	_IsEqualGUID
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN2@SetAudioIn

; 100  :     {
; 101  :         WAVEFORMATEX *pFormat = reinterpret_cast<WAVEFORMATEX*>(audioMediaType->pbFormat);

	mov	eax, DWORD PTR [esi+68]

; 102  :         mcpy(&audioFormat, pFormat, sizeof(audioFormat));

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+32], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+36], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+40], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [edi+44], edx
	mov	ax, WORD PTR [eax+16]
	mov	WORD PTR [edi+48], ax

; 103  : 
; 104  :         Log(TEXT("    device audio info - bits per sample: %u, channels: %u, samples per sec: %u, block size: %u"),
; 105  :             audioFormat.wBitsPerSample, audioFormat.nChannels, audioFormat.nSamplesPerSec, audioFormat.nBlockAlign);

	movzx	ecx, WORD PTR [edi+44]
	mov	edx, DWORD PTR [edi+36]
	movzx	eax, WORD PTR [edi+34]
	push	ecx
	movzx	ecx, WORD PTR [edi+46]
	push	edx
	push	eax
	push	ecx
	push	OFFSET $SG-5579
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 20					; 00000014H

; 106  : 
; 107  :         //avoid local resampling if possible
; 108  :         /*if(pFormat->nSamplesPerSec != 44100)
; 109  :         {
; 110  :             pFormat->nSamplesPerSec = 44100;
; 111  :             if(SUCCEEDED(audioConfig->SetFormat(audioMediaType)))
; 112  :             {
; 113  :                 Log(TEXT("    also successfully set samples per sec to 44.1k"));
; 114  :                 audioFormat.nSamplesPerSec = 44100;
; 115  :             }
; 116  :         }*/
; 117  :     }
; 118  :     else

	jmp	SHORT $LN1@SetAudioIn
$LN2@SetAudioIn:

; 119  :     {
; 120  :         AppWarning(TEXT("DShowAudioPlugin: Audio format was not a normal wave format"));

	push	OFFSET $SG-5580
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 121  :         soundOutputType = 0;

	mov	DWORD PTR [edi+172], ebx
$LN1@SetAudioIn:

; 122  :     }
; 123  : 
; 124  :     DeleteMediaType(audioMediaType);

	mov	edi, DWORD PTR __imp__CoTaskMemFree@4
	cmp	DWORD PTR [esi+64], ebx
	je	SHORT $LN11@SetAudioIn
	mov	edx, DWORD PTR [esi+68]
	push	edx
	call	edi
	mov	DWORD PTR [esi+64], ebx
	mov	DWORD PTR [esi+68], ebx
$LN11@SetAudioIn:
	mov	eax, DWORD PTR [esi+60]
	cmp	eax, ebx
	je	SHORT $LN10@SetAudioIn
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+60], ebx
$LN10@SetAudioIn:
	push	esi
	call	edi
	pop	edi
	pop	ebx

; 125  : }

	ret	0
?SetAudioInfo@DeviceSource@@AAEXPAU_AMMediaType@@AAU_GUID@@@Z ENDP ; DeviceSource::SetAudioInfo
; Function compile flags: /Ogtp
;	COMDAT ?Preprocess@DeviceSource@@UAEXXZ
_TEXT	SEGMENT
_basicAudio$91374 = -4					; size = 4
?Preprocess@DeviceSource@@UAEXXZ PROC			; DeviceSource::Preprocess, COMDAT
; _this$ = ecx

; 680  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 681  :     if(!bCapturing)

	cmp	BYTE PTR [esi+192], 0
	je	$LN27@Preprocess

; 682  :         return;
; 683  : 
; 684  :     //----------------------------------------
; 685  : 
; 686  :     if(bRequestVolume)

	cmp	BYTE PTR [esi+56], 0
	je	SHORT $LN7@Preprocess

; 687  :     {
; 688  :         if(audioOut)

	mov	ecx, DWORD PTR [esi+52]
	test	ecx, ecx
	je	SHORT $LN6@Preprocess

; 689  :             audioOut->SetVolume(fNewVol);

	fld	DWORD PTR [esi+60]
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?SetVolume@AudioSource@@QAEXM@Z
	jmp	SHORT $LN3@Preprocess
$LN6@Preprocess:

; 690  :         else if(audioFilter)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN3@Preprocess

; 691  :         {
; 692  :             IBasicAudio *basicAudio;
; 693  :             if(SUCCEEDED(audioFilter->QueryInterface(IID_IBasicAudio, (void**)&basicAudio)))

	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _basicAudio$91374[ebp]
	push	edx
	push	OFFSET _IID_IBasicAudio
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	test	eax, eax
	js	SHORT $LN3@Preprocess

; 694  :             {
; 695  :                 long lVol = long((double(fNewVol)*NEAR_SILENTf)-NEAR_SILENTf);

	fld	DWORD PTR [esi+60]
	fld	QWORD PTR __real@40a7700000000000
	fmul	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	call	__ftol2_sse

; 696  :                 if(lVol <= -NEAR_SILENT)

	cmp	eax, -3000				; fffff448H
	jg	SHORT $LN2@Preprocess

; 697  :                     lVol = -10000;

	mov	eax, -10000				; ffffd8f0H
$LN2@Preprocess:

; 698  :                 basicAudio->put_Volume(lVol);

	mov	ecx, DWORD PTR _basicAudio$91374[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+28]
	push	ecx
	call	eax

; 699  :                 basicAudio->Release();

	mov	eax, DWORD PTR _basicAudio$91374[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
$LN3@Preprocess:

; 700  :             }
; 701  :         }
; 702  :         bRequestVolume = false;

	mov	BYTE PTR [esi+56], 0
$LN7@Preprocess:

; 703  :     }
; 704  : 
; 705  :     //----------------------------------------
; 706  : 
; 707  :     SampleData *lastSample = NULL;
; 708  : 
; 709  :     OSEnterMutex(hSampleMutex);

	mov	eax, DWORD PTR [esi+208]
	push	edi
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 710  : 
; 711  :     lastSample = latestVideoSample;
; 712  :     latestVideoSample = NULL;
; 713  : 
; 714  :     OSLeaveMutex(hSampleMutex);

	mov	ecx, DWORD PTR [esi+208]
	mov	edi, DWORD PTR [esi+220]
	push	ecx
	mov	DWORD PTR [esi+220], 0
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 715  : 
; 716  :     //----------------------------------------
; 717  : 
; 718  :     int numThreads = MAX(OSGetTotalCores()-2, 1);

	mov	esi, DWORD PTR __imp_?OSGetTotalCores@@YGHXZ
	call	esi
	sub	eax, 2
	cmp	eax, 1
	jle	SHORT $LN11@Preprocess
	call	esi
$LN11@Preprocess:

; 719  : 
; 720  :     if(lastSample)

	test	edi, edi
	je	SHORT $LN29@Preprocess

; 721  :     {
; 722  :         /*REFERENCE_TIME refTimeStart, refTimeFinish;
; 723  :         lastSample->GetTime(&refTimeStart, &refTimeFinish);
; 724  : 
; 725  :         static REFERENCE_TIME lastRefTime = 0;
; 726  :         //Log(TEXT("refTimeStart: %llu, refTimeFinish: %llu, offset = %llu"), refTimeStart, refTimeFinish, refTimeStart-lastRefTime);
; 727  :         lastRefTime = refTimeStart;*/
; 728  : 
; 729  :         lastSample->Release();

	lea	edx, DWORD PTR [edi+24]
	push	edx
	call	DWORD PTR __imp__InterlockedDecrement@4
	test	eax, eax
	jne	SHORT $LN29@Preprocess
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+12]
	push	eax
	call	edx
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	edi
	call	eax
$LN29@Preprocess:
	pop	edi
$LN27@Preprocess:
	pop	esi

; 730  :     }
; 731  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Preprocess@DeviceSource@@UAEXXZ ENDP			; DeviceSource::Preprocess
_TEXT	ENDS
PUBLIC	?LoadFilters@DeviceSource@@AAE_NXZ		; DeviceSource::LoadFilters
;	COMDAT xdata$x
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\alloc.h
xdata$x	SEGMENT
__ehfuncinfo$?LoadFilters@DeviceSource@@AAE_NXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LoadFilters@DeviceSource@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?LoadFilters@DeviceSource@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$6
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$7
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$8
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$9
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$10
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.cpp
xdata$x	ENDS
;	COMDAT ?LoadFilters@DeviceSource@@AAE_NXZ
_TEXT	SEGMENT
_expectedMediaType$ = -88				; size = 16
_expectedAudioType$ = -88				; size = 16
_strShader$ = -72					; size = 8
_outputList$ = -64					; size = 8
_strTest$91127 = -56					; size = 8
$T106875 = -48						; size = 8
$T107105 = -44						; size = 4
$T107086 = -44						; size = 4
$T106885 = -44						; size = 4
$T106881 = -44						; size = 4
$T106877 = -44						; size = 4
_i$91146 = -44						; size = 4
_iLenDiv4$107097 = -40					; size = 4
_iLenDiv4$107078 = -40					; size = 4
_volume$ = -40						; size = 4
_basicAudio$91178 = -36					; size = 4
_audioConfig$91133 = -36				; size = 4
_audioMediaTypes$91143 = -32				; size = 4
_audioMediaType$91137 = -28				; size = 4
_audioPin$ = -24					; size = 4
_bAddedDevice$ = -20					; size = 1
_bAddedAudioCapture$ = -19				; size = 1
_bAddedVideoCapture$ = -18				; size = 1
_bSucceeded$ = -17					; size = 1
__$EHRec$ = -12						; size = 12
$T107111 = 8						; size = 4
_lpData$91241 = 8					; size = 4
_this$ = 8						; size = 4
?LoadFilters@DeviceSource@@AAE_NXZ PROC			; DeviceSource::LoadFilters, COMDAT

; 128  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadFilters@DeviceSource@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 129  :     if(bCapturing || bFiltersLoaded)

	mov	edi, DWORD PTR _this$[ebp]
	xor	eax, eax
	cmp	BYTE PTR [edi+192], al
	jne	$LN73@LoadFilter
	cmp	BYTE PTR [edi+193], al
	jne	$LN73@LoadFilter

; 131  : 
; 132  :     bool bSucceeded = false;

	mov	BYTE PTR _bSucceeded$[ebp], al

; 133  : 
; 134  :     List<MediaOutputInfo> outputList;

	mov	DWORD PTR _outputList$[ebp], eax
	mov	DWORD PTR _outputList$[ebp+4], eax
	mov	DWORD PTR __$EHRec$[ebp+8], eax

; 135  :     IAMStreamConfig *config = NULL;
; 136  :     bool bAddedVideoCapture = false, bAddedAudioCapture = false, bAddedDevice = false;
; 137  :     GUID expectedMediaType;
; 138  :     IPin *devicePin = NULL, *audioPin = NULL;
; 139  :     HRESULT err;
; 140  :     String strShader;

	lea	ecx, DWORD PTR _strShader$[ebp]
	mov	BYTE PTR _bAddedVideoCapture$[ebp], al
	mov	BYTE PTR _bAddedAudioCapture$[ebp], al
	mov	BYTE PTR _bAddedDevice$[ebp], al
	mov	DWORD PTR _audioPin$[ebp], eax
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 141  : 
; 142  :     bUseThreadedConversion = API->UseMultithreadedOptimizations() && (OSGetTotalCores() > 1);

	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+120]
	call	eax
	test	al, al
	je	SHORT $LN77@LoadFilter
	call	DWORD PTR __imp_?OSGetTotalCores@@YGHXZ
	cmp	eax, 1
	jle	SHORT $LN77@LoadFilter
	mov	eax, 1
	jmp	SHORT $LN78@LoadFilter
$LN77@LoadFilter:
	xor	eax, eax
$LN78@LoadFilter:

; 143  : 
; 144  :     //------------------------------------------------
; 145  :     // basic initialization vars
; 146  : 
; 147  :     bool bCheckForceAudio = data->GetInt(TEXT("forceCustomAudioDevice")) != 0;

	mov	ecx, DWORD PTR [edi+184]
	mov	esi, DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	push	0
	push	OFFSET $SG-5581
	mov	BYTE PTR [edi+169], al
	call	esi

; 148  : 
; 149  :     bUseCustomResolution = data->GetInt(TEXT("customResolution"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5582
	call	esi

; 150  :     strDevice = data->GetString(TEXT("device"));

	mov	ecx, DWORD PTR [edi+184]
	mov	esi, DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	0
	push	OFFSET $SG-5583
	mov	DWORD PTR [edi+144], eax
	call	esi
	push	eax
	lea	ecx, DWORD PTR [edi+68]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 151  :     strDeviceName = data->GetString(TEXT("deviceName"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5584
	call	esi
	push	eax
	lea	ecx, DWORD PTR [edi+76]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 152  :     strDeviceID = data->GetString(TEXT("deviceID"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5585
	call	esi
	push	eax
	lea	ecx, DWORD PTR [edi+84]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 153  :     strAudioDevice = data->GetString(TEXT("audioDevice"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5586
	call	esi
	push	eax
	lea	ecx, DWORD PTR [edi+92]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 154  :     strAudioName = data->GetString(TEXT("audioDeviceName"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5587
	call	esi
	push	eax
	lea	ecx, DWORD PTR [edi+100]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 155  :     strAudioID = data->GetString(TEXT("audioDeviceID"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5588
	call	esi
	push	eax
	lea	ecx, DWORD PTR [edi+108]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 156  :     strAudioGUID = data->GetString(TEXT("audioDeviceCLSID"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5589
	call	esi
	push	eax
	lea	ecx, DWORD PTR [edi+116]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 157  : 
; 158  :     if(strAudioGUID.Compare(TEXT("CLSID_AudioInputDeviceCategory"))) matchGUID = CLSID_AudioInputDeviceCategory;

	mov	esi, DWORD PTR __imp_?Compare@String@@QBEHPB_W@Z
	push	OFFSET $SG-5590
	lea	ecx, DWORD PTR [edi+116]
	call	esi
	test	eax, eax
	je	SHORT $LN72@LoadFilter
	mov	ecx, DWORD PTR _CLSID_AudioInputDeviceCategory
	mov	DWORD PTR [edi+152], ecx
	mov	edx, DWORD PTR _CLSID_AudioInputDeviceCategory+4
	mov	DWORD PTR [edi+156], edx
	mov	eax, DWORD PTR _CLSID_AudioInputDeviceCategory+8
	mov	DWORD PTR [edi+160], eax
	mov	ecx, DWORD PTR _CLSID_AudioInputDeviceCategory+12
	mov	DWORD PTR [edi+164], ecx
$LN72@LoadFilter:

; 159  :     if(strAudioGUID.Compare(TEXT("CLSID_VideoInputDeviceCategory"))) matchGUID = CLSID_VideoInputDeviceCategory;

	push	OFFSET $SG-5591
	lea	ecx, DWORD PTR [edi+116]
	call	esi
	test	eax, eax
	je	SHORT $LN71@LoadFilter
	mov	edx, DWORD PTR _CLSID_VideoInputDeviceCategory
	mov	DWORD PTR [edi+152], edx
	mov	eax, DWORD PTR _CLSID_VideoInputDeviceCategory+4
	mov	DWORD PTR [edi+156], eax
	mov	ecx, DWORD PTR _CLSID_VideoInputDeviceCategory+8
	mov	DWORD PTR [edi+160], ecx
	mov	edx, DWORD PTR _CLSID_VideoInputDeviceCategory+12
	mov	DWORD PTR [edi+164], edx
$LN71@LoadFilter:

; 160  :     if(strAudioGUID.Compare(TEXT("CLSID_AudioRendererCategory"))) {

	push	OFFSET $SG-5592
	lea	ecx, DWORD PTR [edi+116]
	call	esi
	test	eax, eax
	je	SHORT $LN70@LoadFilter

; 161  :         //Log(TEXT("Dese are spekers.\n"));
; 162  :         matchGUID = CLSID_AudioRendererCategory;

	mov	eax, DWORD PTR _CLSID_AudioRendererCategory
	mov	DWORD PTR [edi+152], eax
	mov	ecx, DWORD PTR _CLSID_AudioRendererCategory+4
	mov	DWORD PTR [edi+156], ecx
	mov	edx, DWORD PTR _CLSID_AudioRendererCategory+8
	mov	DWORD PTR [edi+160], edx
	mov	eax, DWORD PTR _CLSID_AudioRendererCategory+12
	mov	DWORD PTR [edi+164], eax
$LN70@LoadFilter:

; 163  :     }
; 164  : 
; 165  :     bFlipVertical = data->GetInt(TEXT("flipImage")) != 0;

	mov	ecx, DWORD PTR [edi+184]
	mov	esi, DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	push	0
	push	OFFSET $SG-5593
	call	esi
	test	eax, eax
	setne	cl

; 166  :     bFlipHorizontal = data->GetInt(TEXT("flipImageHorizontal")) != 0;

	push	0
	mov	BYTE PTR [edi+124], cl
	mov	ecx, DWORD PTR [edi+184]
	push	OFFSET $SG-5594
	call	esi

; 167  : 
; 168  :     opacity = data->GetInt(TEXT("opacity"), 100);

	mov	ecx, DWORD PTR [edi+184]
	test	eax, eax
	push	100					; 00000064H
	setne	dl
	push	OFFSET $SG-5595
	mov	BYTE PTR [edi+125], dl
	call	esi

; 169  : 
; 170  :     float volume = data->GetFloat(TEXT("volume"), 1.0f);

	fld1
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR [edi+184]
	push	OFFSET $SG-5596
	mov	DWORD PTR [edi+232], eax
	call	DWORD PTR __imp_?GetFloat@XElement@@QBEMPB_WM@Z
	fstp	DWORD PTR _volume$[ebp]

; 171  : 
; 172  :     //------------------------------------------------
; 173  :     // chrom key stuff
; 174  : 
; 175  :     bUseChromaKey = data->GetInt(TEXT("useChromaKey")) != 0;

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5597
	call	esi

; 176  :     keyColor = data->GetInt(TEXT("keyColor"), 0xFFFFFFFF);

	mov	ecx, DWORD PTR [edi+184]
	test	eax, eax
	push	-1
	setne	al
	push	OFFSET $SG-5598
	mov	BYTE PTR [edi+248], al
	call	esi

; 177  :     keySimilarity = data->GetInt(TEXT("keySimilarity"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5599
	mov	DWORD PTR [edi+252], eax
	call	esi

; 178  :     keyBlend = data->GetInt(TEXT("keyBlend"), 80);

	mov	ecx, DWORD PTR [edi+184]
	push	80					; 00000050H
	push	OFFSET $SG-5600
	mov	DWORD PTR [edi+288], eax
	call	esi

; 179  :     keySpillReduction = data->GetInt(TEXT("keySpillReduction"), 50);

	mov	ecx, DWORD PTR [edi+184]
	push	50					; 00000032H
	push	OFFSET $SG-5601
	mov	DWORD PTR [edi+292], eax
	call	esi

; 180  : 
; 181  :     if(keyBaseColor.x < keyBaseColor.y && keyBaseColor.x < keyBaseColor.z)

	fld	DWORD PTR [edi+272]
	fld	DWORD PTR [edi+276]
	mov	DWORD PTR [edi+296], eax
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN69@LoadFilter
	fld	DWORD PTR [edi+272]
	fld	DWORD PTR [edi+280]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN69@LoadFilter

; 182  :         keyBaseColor -= keyBaseColor.x;

	movss	xmm0, DWORD PTR [edi+272]
	jmp	SHORT $LN228@LoadFilter
$LN69@LoadFilter:

; 183  :     else if(keyBaseColor.y < keyBaseColor.x && keyBaseColor.y < keyBaseColor.z)

	fld	DWORD PTR [edi+276]
	fld	DWORD PTR [edi+272]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN67@LoadFilter
	fld	DWORD PTR [edi+276]
	fld	DWORD PTR [edi+280]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN67@LoadFilter

; 184  :         keyBaseColor -= keyBaseColor.y;

	movss	xmm0, DWORD PTR [edi+276]
	jmp	SHORT $LN228@LoadFilter
$LN67@LoadFilter:

; 185  :     else if(keyBaseColor.z < keyBaseColor.x && keyBaseColor.z < keyBaseColor.y)

	fld	DWORD PTR [edi+280]
	fld	DWORD PTR [edi+272]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN102@LoadFilter
	fld	DWORD PTR [edi+280]
	fld	DWORD PTR [edi+276]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN102@LoadFilter

; 186  :         keyBaseColor -= keyBaseColor.z;

	movss	xmm0, DWORD PTR [edi+280]
$LN228@LoadFilter:
	movaps	xmm1, XMMWORD PTR [edi+272]
	shufps	xmm0, xmm0, 0
	subps	xmm1, xmm0
	movaps	XMMWORD PTR [edi+272], xmm1
$LN102@LoadFilter:

; 187  : 
; 188  :     //------------------------------------------------
; 189  :     // get the device filter and pins
; 190  : 
; 191  :     if(strAudioDevice.IsValid())

	mov	eax, DWORD PTR [edi+92]
	test	eax, eax
	je	SHORT $LN63@LoadFilter
	cmp	WORD PTR [eax], 0
	je	SHORT $LN63@LoadFilter
	cmp	DWORD PTR [edi+96], 0
	je	SHORT $LN63@LoadFilter

; 192  :     {
; 193  :         audioDeviceFilter = GetDeviceByValue(matchGUID, L"FriendlyName", strAudioName, L"DevicePath", strAudioID);

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [edi+100]
	push	eax
	push	OFFSET $SG-5602
	push	ecx
	lea	ecx, DWORD PTR [edi+152]
	push	OFFSET $SG-5603
	push	ecx
	call	?GetDeviceByValue@@YAPAUIBaseFilter@@ABU_GUID@@PA_WPB_W12@Z ; GetDeviceByValue
	add	esp, 20					; 00000014H
	mov	DWORD PTR [edi+20], eax

; 194  :         if(!audioDeviceFilter) {

	test	eax, eax
	jne	SHORT $LN63@LoadFilter

; 195  :             AppWarning(TEXT("DShowAudioPlugin: Invalid audio device: name '%s', path '%s'"), strAudioName.Array(), strAudioID.Array());

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [edi+100]
	push	eax
	push	ecx
	push	OFFSET $SG-5604
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 12					; 0000000cH
$LN63@LoadFilter:

; 196  :         }
; 197  :     }
; 198  : 
; 199  :     soundOutputType = data->GetInt(TEXT("soundOutputType"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5605
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z

; 200  : 
; 201  :     if(soundOutputType != 0)

	mov	esi, DWORD PTR __imp_?Log@@YAXPB_WZZ
	mov	DWORD PTR [edi+172], eax
	test	eax, eax
	je	SHORT $LN59@LoadFilter

; 202  :     {
; 203  :         if(matchGUID == CLSID_AudioRendererCategory) {

	lea	edx, DWORD PTR [edi+152]
	mov	ecx, OFFSET _CLSID_AudioRendererCategory
	call	_IsEqualGUID
	test	eax, eax

; 204  :             err = capture->FindPin(audioDeviceFilter, PINDIR_OUTPUT, &PIN_CATEGORY_CAPTURE, &MEDIATYPE_Audio, FALSE, 0, &audioPin);

	mov	eax, DWORD PTR [edi+8]
	je	SHORT $LN61@LoadFilter
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR _audioPin$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edi+20]
	push	0
	push	0
	push	OFFSET _MEDIATYPE_Audio
	push	OFFSET _PIN_CATEGORY_CAPTURE
	push	1
	push	ecx
	push	eax
	call	edx

; 205  :         }
; 206  :         else {

	jmp	SHORT $LN60@LoadFilter
$LN61@LoadFilter:

; 207  :             err = capture->FindPin(audioDeviceFilter, PINDIR_OUTPUT, &PIN_CATEGORY_CAPTURE, &MEDIATYPE_Audio, FALSE, 0, &audioPin);

	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _audioPin$[ebp]
	push	edx
	mov	edx, DWORD PTR [edi+20]
	push	0
	push	0
	push	OFFSET _MEDIATYPE_Audio
	push	OFFSET _PIN_CATEGORY_CAPTURE
	push	1
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+44]
	call	eax
$LN60@LoadFilter:

; 208  :         }
; 209  :         if(FAILED(err))

	test	eax, eax
	jns	SHORT $LN59@LoadFilter

; 210  :         {
; 211  :             Log(TEXT("DShowAudioPlugin: No audio pin, result = %lX"), err);

	push	eax
	push	OFFSET $SG-5606
	call	esi
	add	esp, 8

; 212  :             soundOutputType = 0;

	mov	DWORD PTR [edi+172], 0
$LN59@LoadFilter:

; 213  :         }
; 214  :     }
; 215  : 
; 216  :     int soundTimeOffset = data->GetInt(TEXT("soundTimeOffset"));

	mov	ecx, DWORD PTR [edi+184]
	push	0
	push	OFFSET $SG-5607
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z

; 217  : 
; 218  :     //GetOutputList(devicePin, outputList);
; 219  : 
; 220  :     //------------------------------------------------
; 221  :     // initialize the basic video variables and data
; 222  : 
; 223  : 
; 224  :     //------------------------------------------------
; 225  :     // log audio info
; 226  :     {
; 227  :     String strTest;

	lea	ecx, DWORD PTR _strTest$91127[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 228  : 
; 229  :         strTest = FormattedString(TEXT("    audio device: %s,\r\n    audio device id %s,\r\n"), strAudioDevice.Array(), strAudioID.Array());

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR [edi+92]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T106875[ebp]
	push	OFFSET $SG-5608
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	eax
	lea	ecx, DWORD PTR _strTest$91127[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T106875[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 230  : 
; 231  :         Log(TEXT("------------------------------------------"));

	push	OFFSET $SG-5609
	call	esi

; 232  :         Log(strTest.Array());

	mov	edx, DWORD PTR _strTest$91127[ebp]
	add	esp, 4
	push	edx
	call	esi
	add	esp, 4

; 233  :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTest$91127[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 234  : 
; 235  :     //------------------------------------------------
; 236  :     // get audio pin configuration, optionally configure audio pin to 44100
; 237  : 
; 238  :     GUID expectedAudioType;
; 239  : 
; 240  :     if(soundOutputType == 1)

	cmp	DWORD PTR [edi+172], 1
	jne	$LN48@LoadFilter

; 241  :     {
; 242  :         IAMStreamConfig *audioConfig;
; 243  :         if(SUCCEEDED(audioPin->QueryInterface(IID_IAMStreamConfig, (void**)&audioConfig)))

	mov	eax, DWORD PTR _audioPin$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _audioConfig$91133[ebp]
	push	edx
	push	OFFSET _IID_IAMStreamConfig
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	test	eax, eax
	js	$LN57@LoadFilter

; 244  :         {
; 245  :             AM_MEDIA_TYPE *audioMediaType;
; 246  :             if(SUCCEEDED(err = audioConfig->GetFormat(&audioMediaType)))

	mov	eax, DWORD PTR _audioConfig$91133[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _audioMediaType$91137[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax
	test	eax, eax
	js	SHORT $LN56@LoadFilter

; 247  :             {
; 248  :                 SetAudioInfo(audioMediaType, expectedAudioType);

	mov	esi, DWORD PTR _audioMediaType$91137[ebp]
	lea	eax, DWORD PTR _expectedAudioType$[ebp]
	mov	ecx, edi
	call	?SetAudioInfo@DeviceSource@@AAEXPAU_AMMediaType@@AAU_GUID@@@Z ; DeviceSource::SetAudioInfo

; 279  :                 soundOutputType = 0;
; 280  :             }
; 281  : 
; 282  :             audioConfig->Release();

	mov	eax, DWORD PTR _audioConfig$91133[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx

; 283  :         }
; 284  :         else {

	jmp	$LN48@LoadFilter
$LN56@LoadFilter:

; 249  :                 //Log(TEXT("Fixed size samples: %s\r\n"), (audioMediaType->bFixedSizeSamples) ? "Yes" : "No");
; 250  :                 //Log(TEXT("Temporal Compression: %s\r\n"), (audioMediaType->bTemporalCompression) ? "Yes" : "No");
; 251  :                 //Log(TEXT("cbFormat: %.16X\r\n"), audioMediaType->cbFormat);
; 252  :                 //Log(TEXT("Sample size: %u\r\n"), audioMediaType->lSampleSize);
; 253  :             }
; 254  :             else if(err == E_NOTIMPL) //elgato probably

	cmp	eax, -2147467263			; 80004001H
	jne	$LN54@LoadFilter

; 255  :             {
; 256  :                 IEnumMediaTypes *audioMediaTypes;
; 257  :                 if(SUCCEEDED(err = audioPin->EnumMediaTypes(&audioMediaTypes)))

	mov	eax, DWORD PTR _audioPin$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _audioMediaTypes$91143[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	test	eax, eax
	js	SHORT $LN53@LoadFilter

; 258  :                 {
; 259  :                     ULONG i = 0;
; 260  :                     if((err = audioMediaTypes->Next(1, &audioMediaType, &i)) == S_OK)

	mov	eax, DWORD PTR _audioMediaTypes$91143[ebp]
	lea	edx, DWORD PTR _i$91146[ebp]
	push	edx
	lea	edx, DWORD PTR _audioMediaType$91137[ebp]
	push	edx
	mov	DWORD PTR _i$91146[ebp], 0
	mov	ecx, DWORD PTR [eax]
	push	1
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	test	eax, eax
	jne	SHORT $LN52@LoadFilter

; 261  :                         SetAudioInfo(audioMediaType, expectedAudioType);

	mov	esi, DWORD PTR _audioMediaType$91137[ebp]
	lea	eax, DWORD PTR _expectedAudioType$[ebp]
	mov	ecx, edi
	call	?SetAudioInfo@DeviceSource@@AAEXPAU_AMMediaType@@AAU_GUID@@@Z ; DeviceSource::SetAudioInfo

; 265  :                         soundOutputType = 0;
; 266  :                     }
; 267  : 
; 268  :                     audioMediaTypes->Release();

	mov	eax, DWORD PTR _audioMediaTypes$91143[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx

; 279  :                 soundOutputType = 0;
; 280  :             }
; 281  : 
; 282  :             audioConfig->Release();

	mov	eax, DWORD PTR _audioConfig$91133[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx

; 283  :         }
; 284  :         else {

	jmp	SHORT $LN48@LoadFilter
$LN52@LoadFilter:

; 262  :                     else
; 263  :                     {
; 264  :                         AppWarning(TEXT("DShowAudioPlugin: audioMediaTypes->Next failed, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5610
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ

; 265  :                         soundOutputType = 0;
; 266  :                     }
; 267  : 
; 268  :                     audioMediaTypes->Release();

	mov	eax, DWORD PTR _audioMediaTypes$91143[ebp]
	mov	DWORD PTR [edi+172], 0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	add	esp, 8
	push	eax
	call	edx

; 279  :                 soundOutputType = 0;
; 280  :             }
; 281  : 
; 282  :             audioConfig->Release();

	mov	eax, DWORD PTR _audioConfig$91133[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx

; 283  :         }
; 284  :         else {

	jmp	SHORT $LN48@LoadFilter
$LN53@LoadFilter:

; 269  :                 }
; 270  :                 else
; 271  :                 {
; 272  :                     AppWarning(TEXT("DShowAudioPlugin: audioMediaTypes->Next failed, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5611

; 273  :                     soundOutputType = 0;
; 274  :                 }
; 275  :             }
; 276  :             else

	jmp	SHORT $LN229@LoadFilter
$LN54@LoadFilter:

; 277  :             {
; 278  :                 AppWarning(TEXT("DShowAudioPlugin: Could not get audio format, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5612
$LN229@LoadFilter:
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ

; 279  :                 soundOutputType = 0;
; 280  :             }
; 281  : 
; 282  :             audioConfig->Release();

	mov	eax, DWORD PTR _audioConfig$91133[ebp]
	mov	DWORD PTR [edi+172], 0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	add	esp, 8
	push	eax
	call	edx

; 283  :         }
; 284  :         else {

	jmp	SHORT $LN48@LoadFilter
$LN57@LoadFilter:

; 285  :             soundOutputType = 0;

	mov	DWORD PTR [edi+172], 0
$LN48@LoadFilter:

; 286  :         }
; 287  :     }
; 288  : 
; 289  :     //------------------------------------------------
; 290  :     // add video capture filter if any
; 291  : 
; 292  :     captureFilter = new CaptureFilter(this, MEDIATYPE_Video, expectedMediaType);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	20					; 00000014H
	call	eax
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR $T106877[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN79@LoadFilter
	lea	ecx, DWORD PTR _expectedMediaType$[ebp]
	push	ecx
	push	OFFSET _MEDIATYPE_Video
	push	edi
	mov	esi, eax
	call	??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z ; CaptureFilter::CaptureFilter
	jmp	SHORT $LN80@LoadFilter
$LN79@LoadFilter:
	xor	eax, eax
$LN80@LoadFilter:
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 293  : 
; 294  :     if(FAILED(err = graph->AddFilter(captureFilter, NULL)))

	mov	ecx, DWORD PTR [edi+4]
	push	0
	mov	DWORD PTR [edi+24], eax
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	push	ecx
	call	eax
	test	eax, eax
	jns	SHORT $LN47@LoadFilter

; 295  :     {
; 296  :         AppWarning(TEXT("DShowAudioPlugin: Failed to add video capture filter to graph, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5613
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 297  :         goto cleanFinish;

	jmp	$LN27@LoadFilter
$LN47@LoadFilter:

; 298  :     }
; 299  : 
; 300  :     bAddedVideoCapture = true;
; 301  : 
; 302  :     //------------------------------------------------
; 303  :     // add audio capture filter if any
; 304  : 
; 305  :     if(soundOutputType == 1)

	mov	eax, DWORD PTR [edi+172]
	mov	BYTE PTR _bAddedVideoCapture$[ebp], 1
	cmp	eax, 1
	jne	SHORT $LN45@LoadFilter

; 306  :     {
; 307  :         audioFilter = new CaptureFilter(this, MEDIATYPE_Audio, expectedAudioType);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	20					; 00000014H
	call	eax
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR $T106881[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN81@LoadFilter
	lea	ecx, DWORD PTR _expectedAudioType$[ebp]
	push	ecx
	push	OFFSET _MEDIATYPE_Audio
	push	edi
	mov	esi, eax
	call	??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z ; CaptureFilter::CaptureFilter
	jmp	SHORT $LN82@LoadFilter
$LN81@LoadFilter:
	xor	eax, eax
$LN82@LoadFilter:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [edi+28], eax

; 308  :         if(!audioFilter)

	test	eax, eax
	jne	$LN40@LoadFilter

; 309  :         {
; 310  :             AppWarning(TEXT("Failed to create audio capture filter"));

	push	OFFSET $SG-5614
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 311  :             soundOutputType = 0;

	mov	DWORD PTR [edi+172], 0

; 312  :         }
; 313  :     }

	jmp	$LN40@LoadFilter
$LN45@LoadFilter:

; 314  :     else if(soundOutputType == 2)

	cmp	eax, 2
	jne	$LN40@LoadFilter

; 315  :     {
; 316  :         if(FAILED(err = CoCreateInstance(CLSID_DSoundRender, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)&audioFilter)))

	lea	esi, DWORD PTR [edi+28]
	push	esi
	push	OFFSET _IID_IBaseFilter
	push	1
	push	0
	push	OFFSET _CLSID_DSoundRender
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	jns	SHORT $LN41@LoadFilter

; 317  :         {
; 318  :             AppWarning(TEXT("DShowPlugin: failed to create audio renderer, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5615
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 319  :             soundOutputType = 0;

	mov	DWORD PTR [edi+172], 0
$LN41@LoadFilter:

; 320  :         }
; 321  : 
; 322  :         IBasicAudio *basicAudio;
; 323  :         if(SUCCEEDED(audioFilter->QueryInterface(IID_IBasicAudio, (void**)&basicAudio)))

	mov	esi, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx]
	lea	eax, DWORD PTR _basicAudio$91178[ebp]
	push	eax
	push	OFFSET _IID_IBasicAudio
	push	esi
	call	ecx
	test	eax, eax
	js	SHORT $LN40@LoadFilter

; 324  :         {
; 325  :             long lVol = long((double(volume)*NEAR_SILENTf)-NEAR_SILENTf);

	fld	DWORD PTR _volume$[ebp]
	fld	QWORD PTR __real@40a7700000000000
	fmul	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	call	__ftol2_sse

; 326  :             if(lVol <= -NEAR_SILENT)

	cmp	eax, -3000				; fffff448H
	jg	SHORT $LN39@LoadFilter

; 327  :                 lVol = -10000;

	mov	eax, -10000				; ffffd8f0H
$LN39@LoadFilter:

; 328  :             basicAudio->put_Volume(lVol);

	mov	ecx, DWORD PTR _basicAudio$91178[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+28]
	push	ecx
	call	eax

; 329  :             basicAudio->Release();

	mov	eax, DWORD PTR _basicAudio$91178[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
$LN40@LoadFilter:

; 330  :         }
; 331  :     }
; 332  : 
; 333  :     if(soundOutputType != 0)

	cmp	DWORD PTR [edi+172], 0
	je	SHORT $LN38@LoadFilter

; 334  :     {
; 335  :         if(FAILED(err = graph->AddFilter(audioFilter, NULL)))

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	test	eax, eax
	jns	SHORT $LN37@LoadFilter

; 336  :         {
; 337  :             AppWarning(TEXT("DShowAudioPlugin: Failed to add audio capture filter to graph, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5616
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 338  :             goto cleanFinish;

	jmp	$LN27@LoadFilter
$LN37@LoadFilter:

; 339  :         }
; 340  : 
; 341  :         bAddedAudioCapture = true;

	mov	BYTE PTR _bAddedAudioCapture$[ebp], 1
$LN38@LoadFilter:

; 342  :     }
; 343  : 
; 344  :     //------------------------------------------------
; 345  :     // add primary device filter
; 346  : 
; 347  :     if(FAILED(err = graph->AddFilter(audioDeviceFilter, NULL)))

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax
	test	eax, eax
	jns	SHORT $LN35@LoadFilter

; 348  :     {
; 349  :         AppWarning(TEXT("DShowAudioPlugin: Failed to add audio device filter to graph, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5617
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 350  :         goto cleanFinish;

	jmp	$LN27@LoadFilter
$LN35@LoadFilter:

; 351  :     }
; 352  : 
; 353  :     bAddedDevice = true;
; 354  : 
; 355  :     //------------------------------------------------
; 356  :     // connect all pins and set up the whole capture thing
; 357  : 
; 358  :     bool bConnected;
; 359  : 
; 360  :     if(soundOutputType != 0)

	cmp	DWORD PTR [edi+172], 0
	mov	BYTE PTR _bAddedDevice$[ebp], 1
	je	SHORT $LN32@LoadFilter

; 361  :     {
; 362  :         bConnected = SUCCEEDED(err = capture->RenderStream(&PIN_CATEGORY_CAPTURE, &MEDIATYPE_Audio, audioDeviceFilter, NULL, audioFilter));

	mov	edx, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [eax]
	push	edx
	mov	edx, DWORD PTR [edi+20]
	push	0
	push	edx
	push	OFFSET _MEDIATYPE_Audio
	push	OFFSET _PIN_CATEGORY_CAPTURE
	push	eax
	mov	eax, DWORD PTR [ecx+28]
	call	eax
	test	eax, eax
	setns	cl

; 363  :         if(!bConnected)

	test	cl, cl
	jne	SHORT $LN32@LoadFilter

; 364  :         {
; 365  :             AppWarning(TEXT("DShowAudioPlugin: Failed to connect the audio device pin to the audio capture pin, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5618
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 366  :             soundOutputType = 0;

	mov	DWORD PTR [edi+172], 0
$LN32@LoadFilter:

; 367  :         }
; 368  :     }
; 369  : 
; 370  :     if(FAILED(err = graph->QueryInterface(IID_IMediaControl, (void**)&control)))

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [edi+12]
	push	edx
	push	OFFSET _IID_IMediaControl
	push	eax
	mov	eax, DWORD PTR [ecx]
	call	eax
	test	eax, eax
	jns	SHORT $LN31@LoadFilter

; 371  :     {
; 372  :         AppWarning(TEXT("DShowAudioPlugin: Failed to get IMediaControl, result = %08lX"), err);

	push	eax
	push	OFFSET $SG-5619
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8

; 373  :         goto cleanFinish;

	jmp	SHORT $LN27@LoadFilter
$LN31@LoadFilter:

; 374  :     }
; 375  : 
; 376  :     if(soundOutputType == 1)

	cmp	DWORD PTR [edi+172], 1
	jne	SHORT $LN29@LoadFilter

; 377  :     {
; 378  :         audioOut = new DeviceAudioSource;

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	168					; 000000a8H
	call	eax
	mov	edx, eax
	mov	ecx, 42					; 0000002aH
	xor	eax, eax
	mov	edi, edx
	rep stosd
	mov	DWORD PTR $T106885[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	edx, edx
	je	SHORT $LN83@LoadFilter
	push	edx
	call	??0DeviceAudioSource@@QAE@XZ
	mov	esi, eax
	jmp	SHORT $LN84@LoadFilter
$LN83@LoadFilter:
	xor	esi, esi
$LN84@LoadFilter:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edi, DWORD PTR _this$[ebp]

; 379  :         audioOut->Initialize(this);

	mov	eax, edi
	mov	DWORD PTR [edi+52], esi
	call	?Initialize@DeviceAudioSource@@QAE_NPAVDeviceSource@@@Z ; DeviceAudioSource::Initialize

; 380  :         API->AddAudioSource(audioOut);

	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edi+52]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 381  : 
; 382  :         audioOut->SetVolume(volume);

	fld	DWORD PTR _volume$[ebp]
	mov	ecx, DWORD PTR [edi+52]
	push	ecx
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_?SetVolume@AudioSource@@QAEXM@Z
$LN29@LoadFilter:

; 383  :     }
; 384  : 
; 385  :     bSucceeded = true;

	mov	BYTE PTR _bSucceeded$[ebp], 1
$LN27@LoadFilter:

; 386  : 
; 387  : cleanFinish:
; 388  :     SafeRelease(config);
; 389  :     SafeRelease(devicePin);
; 390  :     SafeRelease(audioPin);

	mov	eax, DWORD PTR _audioPin$[ebp]
	test	eax, eax
	je	SHORT $LN26@LoadFilter
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR _audioPin$[ebp], 0
$LN26@LoadFilter:

; 391  : 
; 392  :     for(UINT i=0; i<outputList.Num(); i++)
; 393  :         outputList[i].FreeData();
; 394  : 
; 395  :     if(!bSucceeded)

	xor	al, al
	cmp	BYTE PTR _bSucceeded$[ebp], al
	jne	$LN22@LoadFilter

; 396  :     {
; 397  :         bCapturing = false;

	mov	BYTE PTR [edi+192], al

; 398  : 
; 399  :         if(bAddedVideoCapture)

	cmp	BYTE PTR _bAddedVideoCapture$[ebp], al
	je	SHORT $LN21@LoadFilter

; 400  :             graph->RemoveFilter(captureFilter);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+24]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax
$LN21@LoadFilter:

; 401  :         if(bAddedAudioCapture)

	cmp	BYTE PTR _bAddedAudioCapture$[ebp], 0
	je	SHORT $LN20@LoadFilter

; 402  :             graph->RemoveFilter(audioFilter);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax
$LN20@LoadFilter:

; 403  :         if(bAddedDevice) {

	cmp	BYTE PTR _bAddedDevice$[ebp], 0
	je	SHORT $LN19@LoadFilter

; 404  :             graph->RemoveFilter(audioDeviceFilter);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax

; 405  :             graph->RemoveFilter(deviceFilter);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+16]
	call	eax
$LN19@LoadFilter:

; 406  :         }
; 407  : 
; 408  :         SafeRelease(audioDeviceFilter);

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN18@LoadFilter
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [edi+20], 0
$LN18@LoadFilter:

; 409  :         SafeRelease(deviceFilter);

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN17@LoadFilter
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [edi+16], 0
$LN17@LoadFilter:

; 410  :         SafeRelease(captureFilter);

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN16@LoadFilter
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [edi+24], 0
$LN16@LoadFilter:

; 411  :         SafeRelease(audioFilter);

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN15@LoadFilter
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [edi+28], 0
$LN15@LoadFilter:

; 412  :         SafeRelease(control);

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN14@LoadFilter
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [edi+12], 0
$LN14@LoadFilter:

; 413  : 
; 414  :         if(colorConvertShader)

	mov	ecx, DWORD PTR [edi+196]
	test	ecx, ecx
	je	SHORT $LN13@LoadFilter

; 415  :         {
; 416  :             delete colorConvertShader;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	1
	call	edx

; 417  :             colorConvertShader = NULL;

	mov	DWORD PTR [edi+196], 0
$LN13@LoadFilter:

; 418  :         }
; 419  : 
; 420  :         if(audioOut)

	mov	ecx, DWORD PTR [edi+52]
	test	ecx, ecx
	je	SHORT $LN12@LoadFilter

; 421  :         {
; 422  :             delete audioOut;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	1
	call	edx

; 423  :             audioOut = NULL;

	mov	DWORD PTR [edi+52], 0
$LN12@LoadFilter:

; 424  :         }
; 425  : 
; 426  :         if(lpImageBuffer)

	mov	eax, DWORD PTR [edi+236]
	test	eax, eax
	je	SHORT $LN11@LoadFilter

; 427  :         {
; 428  :             Free(lpImageBuffer);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 429  :             lpImageBuffer = NULL;

	mov	DWORD PTR [edi+236], 0
$LN11@LoadFilter:

; 430  :         }
; 431  : 
; 432  :         bReadyToDraw = true;

	mov	BYTE PTR [edi+170], 1

; 433  :     }
; 434  :     else

	jmp	SHORT $LN10@LoadFilter
$LN22@LoadFilter:

; 435  :         bReadyToDraw = false;

	mov	BYTE PTR [edi+170], al
$LN10@LoadFilter:

; 436  : 
; 437  :     if(!renderCX) renderCX = 32;

	cmp	DWORD PTR [edi+136], 0
	mov	eax, 32					; 00000020H
	jne	SHORT $LN9@LoadFilter
	mov	DWORD PTR [edi+136], eax
$LN9@LoadFilter:

; 438  :     if(!renderCY) renderCY = 32;

	cmp	DWORD PTR [edi+140], 0
	jne	SHORT $LN8@LoadFilter
	mov	DWORD PTR [edi+140], eax
$LN8@LoadFilter:

; 439  : 
; 440  :     //-----------------------------------------------------
; 441  :     // create the texture regardless, will just show up as red to indicate failure
; 442  :     BYTE *textureData = (BYTE*)Allocate(renderCX*renderCY*4);

	mov	eax, DWORD PTR [edi+140]
	imul	eax, DWORD PTR [edi+136]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+4]
	add	eax, eax
	add	eax, eax
	push	eax
	call	edx
	mov	esi, eax

; 443  : 
; 444  :     if(colorType == DeviceOutputType_RGB) //you may be confused, but when directshow outputs RGB, it's actually outputting BGR
; 445  :     {
; 446  :         msetd(textureData, 0xFFFF0000, renderCX*renderCY*4);

	mov	eax, DWORD PTR [edi+140]
	imul	eax, DWORD PTR [edi+136]
	add	eax, eax
	add	eax, eax
	mov	edx, eax
	shr	eax, 2
	and	edx, 3
	cmp	DWORD PTR [edi+64], 0
	mov	ecx, esi
	mov	DWORD PTR _iLenDiv4$107078[ebp], eax
	jne	SHORT $LN7@LoadFilter
	mov	DWORD PTR $T107086[ebp], -65536		; ffff0000H
	test	eax, eax
	je	SHORT $LN166@LoadFilter
	mov	ecx, eax
	mov	eax, -65536				; ffff0000H
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR _iLenDiv4$107078[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [esi+eax*4]
$LN166@LoadFilter:
	test	edx, edx
	je	SHORT $LN164@LoadFilter
	push	edx
	lea	edx, DWORD PTR $T107086[ebp]
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN164@LoadFilter:

; 447  :         texture = CreateTexture(renderCX, renderCY, GS_BGR, textureData, FALSE, FALSE);

	push	0
	push	0
	push	esi
	push	5

; 448  :     }
; 449  :     else //if we're working with planar YUV, we can just use regular RGB textures instead

	jmp	SHORT $LN230@LoadFilter
$LN7@LoadFilter:

; 450  :     {
; 451  :         msetd(textureData, 0xFF0000FF, renderCX*renderCY*4);

	mov	DWORD PTR $T107105[ebp], -16776961	; ff0000ffH
	test	eax, eax
	je	SHORT $LN174@LoadFilter
	mov	ecx, DWORD PTR _iLenDiv4$107097[ebp]
	mov	eax, -16776961				; ff0000ffH
	mov	edi, esi
	rep stosd
	mov	ecx, DWORD PTR _iLenDiv4$107097[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [esi+ecx*4]
$LN174@LoadFilter:
	test	edx, edx
	je	SHORT $LN172@LoadFilter
	push	edx
	lea	edx, DWORD PTR $T107105[ebp]
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN172@LoadFilter:

; 452  :         texture = CreateTexture(renderCX, renderCY, GS_RGB, textureData, FALSE, FALSE);

	push	0
	push	0
	push	esi
	push	3
$LN230@LoadFilter:
	mov	eax, DWORD PTR [edi+140]
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	DWORD PTR $T107111[ebp], eax
	mov	eax, DWORD PTR [edi+136]
	push	eax
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 453  :     }
; 454  : 
; 455  :     if(bSucceeded && bUseThreadedConversion)

	cmp	BYTE PTR _bSucceeded$[ebp], 0
	mov	DWORD PTR [edi+180], eax
	je	SHORT $LN4@LoadFilter
	cmp	BYTE PTR [edi+169], 0
	je	SHORT $LN4@LoadFilter

; 456  :     {
; 457  :         if(colorType == DeviceOutputType_I420 || colorType == DeviceOutputType_YV12)

	mov	eax, DWORD PTR [edi+64]
	cmp	eax, 1
	je	SHORT $LN3@LoadFilter
	cmp	eax, 2
	jne	SHORT $LN4@LoadFilter
$LN3@LoadFilter:

; 458  :         {
; 459  :             LPBYTE lpData;
; 460  :             if(texture->Map(lpData, texturePitch))

	mov	ecx, DWORD PTR [edi+180]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+20]
	lea	eax, DWORD PTR [edi+188]
	push	eax
	lea	eax, DWORD PTR _lpData$91241[ebp]
	push	eax
	call	edx
	test	al, al
	je	SHORT $LN2@LoadFilter

; 461  :                 texture->Unmap();

	mov	ecx, DWORD PTR [edi+180]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+24]
	call	edx

; 462  :             else

	jmp	SHORT $LN1@LoadFilter
$LN2@LoadFilter:

; 463  :                 texturePitch = renderCX*4;

	mov	eax, DWORD PTR [edi+136]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR [edi+188], eax
$LN1@LoadFilter:

; 464  : 
; 465  :             lpImageBuffer = (LPBYTE)Allocate(texturePitch*renderCY);

	mov	eax, DWORD PTR [edi+188]
	imul	eax, DWORD PTR [edi+140]
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+4]
	push	eax
	call	edx
	mov	DWORD PTR [edi+236], eax
$LN4@LoadFilter:

; 466  :         }
; 467  :     }
; 468  : 
; 469  :     Free(textureData);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax

; 470  : 
; 471  :     bFiltersLoaded = bSucceeded;

	mov	cl, BYTE PTR _bSucceeded$[ebp]
	mov	BYTE PTR [edi+193], cl

; 472  :     return bSucceeded;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strShader$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR _bSucceeded$[ebp]

; 473  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN73@LoadFilter:

; 130  :         return false;

	xor	al, al

; 473  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$4:
	lea	esi, DWORD PTR _outputList$[ebp]
	jmp	??1?$List@UMediaOutputInfo@@@@QAE@XZ	; List<MediaOutputInfo>::~List<MediaOutputInfo>
__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$5:
	lea	ecx, DWORD PTR _strShader$[ebp]
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$6:
	lea	ecx, DWORD PTR _strTest$91127[ebp]
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$7:
	lea	ecx, DWORD PTR $T106875[ebp]
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$8:
	mov	eax, DWORD PTR $T106877[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$9:
	mov	eax, DWORD PTR $T106881[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadFilters@DeviceSource@@AAE_NXZ$10:
	mov	eax, DWORD PTR $T106885[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?LoadFilters@DeviceSource@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadFilters@DeviceSource@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadFilters@DeviceSource@@AAE_NXZ ENDP			; DeviceSource::LoadFilters
PUBLIC	?Stop@DeviceSource@@AAEXXZ			; DeviceSource::Stop
; Function compile flags: /Ogtp
;	COMDAT ?Stop@DeviceSource@@AAEXXZ
_TEXT	SEGMENT
?Stop@DeviceSource@@AAEXXZ PROC				; DeviceSource::Stop, COMDAT
; _this$ = eax

; 565  : {

	push	esi
	mov	esi, eax

; 566  :     if(!bCapturing)

	cmp	BYTE PTR [esi+192], 0
	je	SHORT $LN2@Stop

; 567  :         return;
; 568  : 
; 569  :     bCapturing = false;
; 570  :     control->Stop();

	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR [esi+192], 0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+36]
	push	eax
	call	edx

; 571  :     FlushSamples();

	call	?FlushSamples@DeviceSource@@AAEXXZ	; DeviceSource::FlushSamples
$LN2@Stop:
	pop	esi

; 572  : }

	ret	0
?Stop@DeviceSource@@AAEXXZ ENDP				; DeviceSource::Stop
_TEXT	ENDS
PUBLIC	??1DeviceSource@@UAE@XZ				; DeviceSource::~DeviceSource
;	COMDAT xdata$x
; File c:\users\beeanyew\documents\github\obs\obsapi\scene.h
xdata$x	SEGMENT
__ehfuncinfo$??1DeviceSource@@UAE@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??1DeviceSource@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1DeviceSource@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1DeviceSource@@UAE@XZ$8
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.cpp
xdata$x	ENDS
;	COMDAT ??1DeviceSource@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1DeviceSource@@UAE@XZ PROC				; DeviceSource::~DeviceSource, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DeviceSource@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7DeviceSource@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 8

; 74   :     Stop();

	xor	ebx, ebx
	cmp	BYTE PTR [esi+192], bl
	je	SHORT $LN18@DeviceSour
	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR [esi+192], bl
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+36]
	push	eax
	call	edx
	call	?FlushSamples@DeviceSource@@AAEXXZ	; DeviceSource::FlushSamples
$LN18@DeviceSour:

; 75   :     UnloadFilters();

	call	?UnloadFilters@DeviceSource@@AAEXXZ	; DeviceSource::UnloadFilters

; 76   : 
; 77   :     SafeRelease(capture);

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	je	SHORT $LN5@DeviceSour
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+8], ebx
$LN5@DeviceSour:

; 78   :     SafeRelease(graph);

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	je	SHORT $LN4@DeviceSour
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+4], ebx
$LN4@DeviceSour:

; 79   : 
; 80   :     if(hConvertThreads)

	mov	eax, DWORD PTR [esi+244]
	cmp	eax, ebx
	je	SHORT $LN20@DeviceSour

; 81   :         Free(hConvertThreads);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN20@DeviceSour:

; 82   : 
; 83   :     if(convertData)

	mov	eax, DWORD PTR [esi+240]
	cmp	eax, ebx
	je	SHORT $LN22@DeviceSour

; 84   :         Free(convertData);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN22@DeviceSour:

; 85   : 
; 86   :     if(hSampleMutex)

	mov	eax, DWORD PTR [esi+208]
	cmp	eax, ebx
	je	SHORT $LN1@DeviceSour

; 87   :         OSCloseMutex(hSampleMutex);

	push	eax
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN1@DeviceSour:

; 88   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR [esi+224]
	cmp	eax, ebx
	je	SHORT $LN26@DeviceSour
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi+224], ebx
	mov	DWORD PTR [esi+228], ebx
$LN26@DeviceSour:
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edi, DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR [esi+116]
	call	edi
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR [esi+108]
	call	edi
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR [esi+100]
	call	edi
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR [esi+92]
	call	edi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR [esi+84]
	call	edi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR [esi+76]
	call	edi
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	lea	ecx, DWORD PTR [esi+68]
	call	edi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __imp_??_7ImageSource@@6B@
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DeviceSource@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1ImageSource@@UAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__unwindfunclet$??1DeviceSource@@UAE@XZ$8:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 224				; 000000e0H
	jmp	??1?$List@PAUSampleData@@@@QAE@XZ	; List<SampleData *>::~List<SampleData *>
__ehhandler$??1DeviceSource@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DeviceSource@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DeviceSource@@UAE@XZ ENDP				; DeviceSource::~DeviceSource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateSettings@DeviceSource@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateSettings@DeviceSource@@UAEXXZ$0
__ehfuncinfo$?UpdateSettings@DeviceSource@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateSettings@DeviceSource@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?UpdateSettings@DeviceSource@@UAEXXZ
_TEXT	SEGMENT
_newPreferredType$ = -44				; size = 4
_newCY$ = -40						; size = 4
_bNewCustom$ = -36					; size = 4
_newFrameInterval$ = -32				; size = 8
_strNewDevice$ = -24					; size = 8
__$EHRec$ = -12						; size = 12
?UpdateSettings@DeviceSource@@UAEXXZ PROC		; DeviceSource::UpdateSettings, COMDAT
; _this$ = ecx

; 749  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?UpdateSettings@DeviceSource@@UAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 750  :     String strNewDevice     = data->GetString(TEXT("audioDevice"));

	mov	ecx, DWORD PTR [esi+184]
	push	0
	push	OFFSET $SG-5630
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _strNewDevice$[esp+64]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z
	mov	DWORD PTR __$EHRec$[esp+68], 0

; 751  :     UINT64 newFrameInterval = data->GetInt(TEXT("frameInterval"));

	mov	ecx, DWORD PTR [esi+184]
	mov	edi, DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	push	0
	push	OFFSET $SG-5631
	call	edi

; 752  :     UINT newCX              = data->GetInt(TEXT("resolutionWidth"));

	mov	ecx, DWORD PTR [esi+184]
	cdq
	push	0
	push	OFFSET $SG-5632
	mov	DWORD PTR _newFrameInterval$[esp+68], eax
	mov	DWORD PTR _newFrameInterval$[esp+72], edx
	call	edi

; 753  :     UINT newCY              = data->GetInt(TEXT("resolutionHeight"));

	mov	ecx, DWORD PTR [esi+184]
	push	0
	push	OFFSET $SG-5633
	mov	ebx, eax
	call	edi

; 754  :     BOOL bNewCustom         = data->GetInt(TEXT("customResolution"));

	mov	ecx, DWORD PTR [esi+184]
	push	0
	push	OFFSET $SG-5634
	mov	DWORD PTR _newCY$[esp+68], eax
	call	edi

; 755  :     UINT newPreferredType   = data->GetInt(TEXT("usePreferredType")) != 0 ? data->GetInt(TEXT("preferredType")) : -1;

	mov	ecx, DWORD PTR [esi+184]
	push	0
	push	OFFSET $SG-5635
	mov	DWORD PTR _bNewCustom$[esp+68], eax
	call	edi
	test	eax, eax
	je	SHORT $LN7@UpdateSett
	mov	ecx, DWORD PTR [esi+184]
	push	0
	push	OFFSET $SG-5636
	call	edi
	mov	DWORD PTR _newPreferredType$[esp+60], eax
	jmp	SHORT $LN8@UpdateSett
$LN7@UpdateSett:
	mov	DWORD PTR _newPreferredType$[esp+60], -1
$LN8@UpdateSett:

; 756  :     UINT newSoundOutputType     = data->GetInt(TEXT("soundOutputType"));

	mov	ecx, DWORD PTR [esi+184]
	push	0
	push	OFFSET $SG-5637
	call	edi
	mov	edi, eax

; 757  : 
; 758  :     if(renderCX != newCX || renderCY != newCY || frameInterval != newFrameInterval || newPreferredType != preferredOutputType ||
; 759  :         !strAudioDevice.CompareI(strNewDevice) || bNewCustom != bUseCustomResolution ||
; 760  :         newSoundOutputType != soundOutputType)

	cmp	DWORD PTR [esi+136], ebx
	jne	SHORT $LN3@UpdateSett
	mov	eax, DWORD PTR _newCY$[esp+60]
	cmp	DWORD PTR [esi+140], eax
	jne	SHORT $LN3@UpdateSett
	mov	ecx, DWORD PTR [esi+128]
	cmp	ecx, DWORD PTR _newFrameInterval$[esp+60]
	jne	SHORT $LN3@UpdateSett
	mov	edx, DWORD PTR [esi+132]
	cmp	edx, DWORD PTR _newFrameInterval$[esp+64]
	jne	SHORT $LN3@UpdateSett
	mov	eax, DWORD PTR _newPreferredType$[esp+60]
	cmp	eax, DWORD PTR [esi+148]
	jne	SHORT $LN3@UpdateSett
	mov	ecx, DWORD PTR _strNewDevice$[esp+60]
	push	ecx
	lea	ecx, DWORD PTR [esi+92]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN3@UpdateSett
	mov	edx, DWORD PTR _bNewCustom$[esp+60]
	cmp	edx, DWORD PTR [esi+144]
	jne	SHORT $LN3@UpdateSett
	cmp	edi, DWORD PTR [esi+172]
	je	$LN4@UpdateSett
$LN3@UpdateSett:

; 761  :     {
; 762  :         API->EnterSceneMutex();

	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 763  : 
; 764  :         bool bWasCapturing = bCapturing;

	mov	bl, BYTE PTR [esi+192]

; 765  :         if(bWasCapturing) Stop();

	test	bl, bl
	je	SHORT $LN13@UpdateSett
	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR [esi+192], 0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+36]
	push	eax
	call	edx
	call	?FlushSamples@DeviceSource@@AAEXXZ	; DeviceSource::FlushSamples
$LN13@UpdateSett:

; 766  : 
; 767  :         UnloadFilters();

	call	?UnloadFilters@DeviceSource@@AAEXXZ	; DeviceSource::UnloadFilters

; 768  :         LoadFilters();

	push	esi
	call	?LoadFilters@DeviceSource@@AAE_NXZ	; DeviceSource::LoadFilters

; 769  : 
; 770  :         if(bWasCapturing) Start();

	test	bl, bl
	je	SHORT $LN16@UpdateSett
	cmp	BYTE PTR [esi+192], 0
	jne	SHORT $LN16@UpdateSett
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN16@UpdateSett
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	push	eax
	call	edx
	test	eax, eax
	jns	SHORT $LN15@UpdateSett
	push	eax
	push	OFFSET $SG-5628
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8
	jmp	SHORT $LN16@UpdateSett
$LN15@UpdateSett:
	mov	BYTE PTR [esi+192], 1
$LN16@UpdateSett:

; 771  : 
; 772  :         API->LeaveSceneMutex();

	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN4@UpdateSett:

; 773  :     }
; 774  : }

	mov	DWORD PTR __$EHRec$[esp+68], -1
	lea	ecx, DWORD PTR _strNewDevice$[esp+60]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateSettings@DeviceSource@@UAEXXZ$0:
	lea	ecx, DWORD PTR _strNewDevice$[ebp]
	jmp	DWORD PTR __imp_??1String@@QAE@XZ
__ehhandler$?UpdateSettings@DeviceSource@@UAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx-44]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateSettings@DeviceSource@@UAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateSettings@DeviceSource@@UAEXXZ ENDP		; DeviceSource::UpdateSettings
; Function compile flags: /Ogtp
;	COMDAT ?EndScene@DeviceSource@@UAEXXZ
_TEXT	SEGMENT
?EndScene@DeviceSource@@UAEXXZ PROC			; DeviceSource::EndScene, COMDAT
; _this$ = ecx

; 580  : {

	push	esi
	mov	esi, ecx

; 581  :     Stop();

	cmp	BYTE PTR [esi+192], 0
	je	SHORT $LN4@EndScene
	mov	eax, DWORD PTR [esi+12]
	mov	BYTE PTR [esi+192], 0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+36]
	push	eax
	call	edx
	call	?FlushSamples@DeviceSource@@AAEXXZ	; DeviceSource::FlushSamples
$LN4@EndScene:
	pop	esi

; 582  : }

	ret	0
?EndScene@DeviceSource@@UAEXXZ ENDP			; DeviceSource::EndScene
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GDeviceSource@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GDeviceSource@@UAEPAXI@Z PROC			; DeviceSource::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	esi
	call	??1DeviceSource@@UAE@XZ			; DeviceSource::~DeviceSource
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar@6
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
$LN8@scalar@6:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GDeviceSource@@UAEPAXI@Z ENDP			; DeviceSource::`scalar deleting destructor'
END
