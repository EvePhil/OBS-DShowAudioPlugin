; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\beeanyew\Documents\GitHub\OBS\DShowAudioPlugin\DeviceAudio.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?ReleaseBuffer@DeviceAudioSource@@MAEXXZ	; DeviceAudioSource::ReleaseBuffer
PUBLIC	?GetNextBuffer@DeviceAudioSource@@MAE_NPAPAXPAIPA_K@Z ; DeviceAudioSource::GetNextBuffer
PUBLIC	?GetDeviceName@DeviceAudioSource@@MBEPB_WXZ	; DeviceAudioSource::GetDeviceName
PUBLIC	??_R4DeviceAudioSource@@6B@			; DeviceAudioSource::`RTTI Complete Object Locator'
PUBLIC	??_R3DeviceAudioSource@@8			; DeviceAudioSource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DeviceAudioSource@@8			; DeviceAudioSource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AudioSource@@8			; AudioSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3AudioSource@@8				; AudioSource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AudioSource@@8				; AudioSource::`RTTI Base Class Array'
PUBLIC	??_R0?AVAudioSource@@@8				; AudioSource `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@DeviceAudioSource@@8		; DeviceAudioSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDeviceAudioSource@@@8			; DeviceAudioSource `RTTI Type Descriptor'
PUBLIC	?Array@?$List@E@@QBEPAEXZ			; List<unsigned char>::Array
PUBLIC	?Num@?$List@E@@QBEIXZ				; List<unsigned char>::Num
PUBLIC	?Remove@?$List@E@@QAEXI@Z			; List<unsigned char>::Remove
PUBLIC	?RemoveRange@?$List@E@@QAEXII@Z			; List<unsigned char>::RemoveRange
PUBLIC	??1?$List@E@@QAE@XZ				; List<unsigned char>::~List<unsigned char>
PUBLIC	??_GDeviceAudioSource@@UAEPAXI@Z		; DeviceAudioSource::`scalar deleting destructor'
PUBLIC	?SetSize@?$List@E@@QAEHI@Z			; List<unsigned char>::SetSize
PUBLIC	?AppendArray@?$List@E@@QAEXPBEI@Z		; List<unsigned char>::AppendArray
PUBLIC	?Clear@?$List@E@@QAEXXZ				; List<unsigned char>::Clear
PUBLIC	??_C@_1GK@FGBPJKAO@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAA?$AAp?$AAp?$AAe?$AAn?$AAd?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@ ; `string'
PUBLIC	??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@ ; `string'
PUBLIC	??_7DeviceAudioSource@@6B@			; DeviceAudioSource::`vftable'
PUBLIC	__GUID_00000003_0000_0010_8000_00aa00389b71
EXTRN	?GetLatestTimestamp@AudioSource@@UAE_NAA_K@Z:PROC ; AudioSource::GetLatestTimestamp
EXTRN	?StopCapture@AudioSource@@UAEXXZ:PROC		; AudioSource::StopCapture
EXTRN	?StartCapture@AudioSource@@UAEXXZ:PROC		; AudioSource::StartCapture
EXTRN	?GetBufferedTime@AudioSource@@UAE_KXZ:PROC	; AudioSource::GetBufferedTime
EXTRN	?GetNewestFrame@AudioSource@@UAE_NPAPAM@Z:PROC	; AudioSource::GetNewestFrame
EXTRN	?GetBuffer@AudioSource@@UAE_NPAPAM_K@Z:PROC	; AudioSource::GetBuffer
EXTRN	?GetEarliestTimestamp@AudioSource@@UAE_NAA_K@Z:PROC ; AudioSource::GetEarliestTimestamp
EXTRN	?QueryAudio@AudioSource@@UAEIM@Z:PROC		; AudioSource::QueryAudio
EXTRN	__imp_?API@@3PAVAPIInterface@@A:DWORD
EXTRN	__imp_?Array@String@@QBEPA_WXZ:PROC
EXTRN	__imp_?OSCreateMutex@@YGPAXXZ:PROC
EXTRN	__imp_?InitAudioData@AudioSource@@IAEX_NIIIIK@Z:PROC
EXTRN	__imp_?OSCloseMutex@@YGXPAX@Z:PROC
EXTRN	__imp_??1AudioSource@@UAE@XZ:PROC
EXTRN	__imp_?QueryAudio@AudioSource@@UAEIM@Z:PROC
EXTRN	__imp_?GetEarliestTimestamp@AudioSource@@UAE_NAA_K@Z:PROC
EXTRN	__imp_?GetBuffer@AudioSource@@UAE_NPAPAM_K@Z:PROC
EXTRN	__imp_?GetNewestFrame@AudioSource@@UAE_NPAPAM@Z:PROC
EXTRN	__imp_?GetBufferedTime@AudioSource@@UAE_KXZ:PROC
EXTRN	__imp_?StartCapture@AudioSource@@UAEXXZ:PROC
EXTRN	__imp_?StopCapture@AudioSource@@UAEXXZ:PROC
EXTRN	__imp_?GetLatestTimestamp@AudioSource@@UAE_NAA_K@Z:PROC
EXTRN	??_EDeviceAudioSource@@UAEPAXI@Z:PROC		; DeviceAudioSource::`vector deleting destructor'
EXTRN	__imp_?AppWarning@@YAXPB_WZZ:PROC
;	COMDAT __GUID_00000003_0000_0010_8000_00aa00389b71
CONST	SEGMENT
__GUID_00000003_0000_0010_8000_00aa00389b71 DD 03H
	DW	00H
	DW	010H
	DB	080H
	DB	00H
	DB	00H
	DB	0aaH
	DB	00H
	DB	038H
	DB	09bH
	DB	071H
CONST	ENDS
;	COMDAT ??_7DeviceAudioSource@@6B@
CONST	SEGMENT
??_7DeviceAudioSource@@6B@ DD FLAT:??_R4DeviceAudioSource@@6B@ ; DeviceAudioSource::`vftable'
	DD	FLAT:?GetDeviceName@DeviceAudioSource@@MBEPB_WXZ
	DD	FLAT:?GetNextBuffer@DeviceAudioSource@@MAE_NPAPAXPAIPA_K@Z
	DD	FLAT:?ReleaseBuffer@DeviceAudioSource@@MAEXXZ
	DD	FLAT:??_EDeviceAudioSource@@UAEPAXI@Z
	DD	FLAT:?QueryAudio@AudioSource@@UAEIM@Z
	DD	FLAT:?GetEarliestTimestamp@AudioSource@@UAE_NAA_K@Z
	DD	FLAT:?GetBuffer@AudioSource@@UAE_NPAPAM_K@Z
	DD	FLAT:?GetNewestFrame@AudioSource@@UAE_NPAPAM@Z
	DD	FLAT:?GetBufferedTime@AudioSource@@UAE_KXZ
	DD	FLAT:?StartCapture@AudioSource@@UAEXXZ
	DD	FLAT:?StopCapture@AudioSource@@UAEXXZ
	DD	FLAT:?GetLatestTimestamp@AudioSource@@UAE_NAA_K@Z
CONST	ENDS
;	COMDAT ??_R4DeviceAudioSource@@6B@
rdata$r	SEGMENT
??_R4DeviceAudioSource@@6B@ DD 00H			; DeviceAudioSource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDeviceAudioSource@@@8
	DD	FLAT:??_R3DeviceAudioSource@@8
rdata$r	ENDS
;	COMDAT ??_R3DeviceAudioSource@@8
rdata$r	SEGMENT
??_R3DeviceAudioSource@@8 DD 00H			; DeviceAudioSource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DeviceAudioSource@@8
rdata$r	ENDS
;	COMDAT ??_R2DeviceAudioSource@@8
rdata$r	SEGMENT
??_R2DeviceAudioSource@@8 DD FLAT:??_R1A@?0A@EA@DeviceAudioSource@@8 ; DeviceAudioSource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AudioSource@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AudioSource@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AudioSource@@8 DD FLAT:??_R0?AVAudioSource@@@8 ; AudioSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AudioSource@@8
rdata$r	ENDS
;	COMDAT ??_R3AudioSource@@8
rdata$r	SEGMENT
??_R3AudioSource@@8 DD 00H				; AudioSource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AudioSource@@8
rdata$r	ENDS
;	COMDAT ??_R2AudioSource@@8
rdata$r	SEGMENT
??_R2AudioSource@@8 DD FLAT:??_R1A@?0A@EA@AudioSource@@8 ; AudioSource::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVAudioSource@@@8
_DATA	SEGMENT
??_R0?AVAudioSource@@@8 DD FLAT:??_7type_info@@6B@	; AudioSource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAudioSource@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@DeviceAudioSource@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DeviceAudioSource@@8 DD FLAT:??_R0?AVDeviceAudioSource@@@8 ; DeviceAudioSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DeviceAudioSource@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDeviceAudioSource@@@8
_DATA	SEGMENT
??_R0?AVDeviceAudioSource@@@8 DD FLAT:??_7type_info@@6B@ ; DeviceAudioSource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDeviceAudioSource@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@
CONST	SEGMENT
??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@ DB 'L'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, ':', 00H, ':', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'R', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' ', 00H, ' ', 00H
	DB	'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd'
	DB	00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H
	DB	' ', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H, 'f'
	DB	00H, 'i', 00H, 'e', 00H, 'd', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@FGBPJKAO@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAA?$AAp?$AAp?$AAe?$AAn?$AAd?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@
CONST	SEGMENT
??_C@_1GK@FGBPJKAO@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAA?$AAp?$AAp?$AAe?$AAn?$AAd?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@ DB 'L'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, ':', 00H, ':', 00H, 'A', 00H
	DB	'p', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'A', 00H, 'r'
	DB	00H, 'r', 00H, 'a', 00H, 'y', 00H, ':', 00H, ' ', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, 'a', 00H, 'r'
	DB	00H, 'r', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'w', 00H, 'i', 00H
	DB	't', 00H, 'h', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, 'a', 00H, 'b', 00H, 'o', 00H, 'v', 00H
	DB	'e', 00H, ' ', 00H, 'z', 00H, 'e', 00H, 'r', 00H, 'o', 00H, 00H
	DB	00H						; `string'
$SG-3204 DB	00H
$SG-3205 DB	00H, 00H
$SG-3223 DB	'M', 00H, 'J', 00H, 'P', 00H, 'G', 00H, 00H, 00H
$SG-3222 DB	'd', 00H, 'v', 00H, 'h', 00H, 'd', 00H, 00H, 00H
$SG-3221 DB	'd', 00H, 'v', 00H, 's', 00H, 'd', 00H, 00H, 00H
$SG-3220 DB	'd', 00H, 'v', 00H, 's', 00H, 'l', 00H, 00H, 00H
$SG-3219 DB	'H', 00H, '2', 00H, '6', 00H, '4', 00H, 00H, 00H
$SG-3217 DB	'H', 00H, 'D', 00H, 'Y', 00H, 'C', 00H, 00H, 00H
$SG-3216 DB	'U', 00H, 'Y', 00H, 'V', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG-3218 DB	'M', 00H, 'P', 00H, 'E', 00H, 'G', 00H, '2', 00H, '_', 00H
	DB	'V', 00H, 'I', 00H, 'D', 00H, 'E', 00H, 'O', 00H, 00H, 00H
$SG-3215 DB	'Y', 00H, 'U', 00H, 'Y', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG-3214 DB	'Y', 00H, 'V', 00H, 'Y', 00H, 'U', 00H, 00H, 00H
	ORG $+2
$SG-3213 DB	'Y', 00H, 'V', 00H, 'U', 00H, '9', 00H, 00H, 00H
	ORG $+2
$SG-3212 DB	'Y', 00H, '4', 00H, '1', 00H, 'P', 00H, 00H, 00H
	ORG $+2
$SG-3211 DB	'Y', 00H, 'V', 00H, '1', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG-3210 DB	'I', 00H, '4', 00H, '2', 00H, '0', 00H, 00H, 00H
	ORG $+2
$SG-3209 DB	'R', 00H, 'G', 00H, 'B', 00H, 'A', 00H, '3', 00H, '2', 00H
	DB	00H, 00H
	ORG $+2
$SG-3208 DB	'R', 00H, 'G', 00H, 'B', 00H, '3', 00H, '2', 00H, 00H, 00H
$SG-3207 DB	'R', 00H, 'G', 00H, 'B', 00H, '2', 00H, '4', 00H, 00H, 00H
$SG-3206 DB	'N', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 00H, 00H
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@E@@QBEIXZ
_TEXT	SEGMENT
?Num@?$List@E@@QBEIXZ PROC				; List<unsigned char>::Num, COMDAT
; _this$ = eax

; 37   :     inline unsigned int Num() const     {return num;}

	mov	eax, DWORD PTR [eax+4]
	ret	0
?Num@?$List@E@@QBEIXZ ENDP				; List<unsigned char>::Num
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Array@?$List@E@@QBEPAEXZ
_TEXT	SEGMENT
?Array@?$List@E@@QBEPAEXZ PROC				; List<unsigned char>::Array, COMDAT
; _this$ = eax

; 36   :     inline T* Array() const             {return array;}

	mov	eax, DWORD PTR [eax]
	ret	0
?Array@?$List@E@@QBEPAEXZ ENDP				; List<unsigned char>::Array
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\deviceaudio.cpp
_TEXT	ENDS
;	COMDAT ?GetDeviceName@DeviceAudioSource@@MBEPB_WXZ
_TEXT	SEGMENT
?GetDeviceName@DeviceAudioSource@@MBEPB_WXZ PROC	; DeviceAudioSource::GetDeviceName, COMDAT
; _this$ = ecx

; 53   :     if(device)

	mov	eax, DWORD PTR [ecx+128]
	test	eax, eax
	je	SHORT $LN1@GetDeviceN

; 54   :         return device->strDeviceName.Array();

	mov	eax, DWORD PTR [eax+76]

; 57   : }

	ret	0
$LN1@GetDeviceN:

; 55   : 
; 56   :     return NULL;

	xor	eax, eax

; 57   : }

	ret	0
?GetDeviceName@DeviceAudioSource@@MBEPB_WXZ ENDP	; DeviceAudioSource::GetDeviceName
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ReleaseBuffer@DeviceAudioSource@@MAEXXZ
_TEXT	SEGMENT
?ReleaseBuffer@DeviceAudioSource@@MAEXXZ PROC		; DeviceAudioSource::ReleaseBuffer, COMDAT
; _this$ = ecx

; 48   : }

	ret	0
?ReleaseBuffer@DeviceAudioSource@@MAEXXZ ENDP		; DeviceAudioSource::ReleaseBuffer
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$List@E@@QAEXI@Z
_TEXT	SEGMENT
?Remove@?$List@E@@QAEXI@Z PROC				; List<unsigned char>::Remove, COMDAT
; _this$ = esi

; 84   :         assert(index < num);
; 85   :         if(index >= num) return;

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN3@Remove

; 86   : 
; 87   :         if(!--num) {Free(array); array=NULL; return;}

	dec	eax
	mov	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@Remove
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+12]
	push	eax
	call	edx
	mov	DWORD PTR [esi], 0

; 92   :     }

	ret	0
$LN1@Remove:

; 88   : 
; 89   :         mcpy(&array[index], &array[index+1], sizeof(T)*(num-index));

	mov	ecx, DWORD PTR [esi]
	push	eax
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	push	ecx
	call	_memcpy

; 90   : 
; 91   :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	edx
	mov	DWORD PTR [esi], eax
$LN3@Remove:

; 92   :     }

	ret	0
?Remove@?$List@E@@QAEXI@Z ENDP				; List<unsigned char>::Remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Clear@?$List@E@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$List@E@@QAEXXZ PROC				; List<unsigned char>::Clear, COMDAT
; _this$ = esi

; 330  :         if(array)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@Clear@4

; 331  :         {
; 332  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 333  :                 CrashError(TEXT("what the.."));*/
; 334  :             Free(array);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 335  :             array = NULL;

	mov	DWORD PTR [esi], 0

; 336  :             num = 0;

	mov	DWORD PTR [esi+4], 0
$LN1@Clear@4:

; 337  :         }
; 338  :     }

	ret	0
?Clear@?$List@E@@QAEXXZ ENDP				; List<unsigned char>::Clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetSize@?$List@E@@QAEHI@Z
_TEXT	SEGMENT
?SetSize@?$List@E@@QAEHI@Z PROC				; List<unsigned char>::SetSize, COMDAT
; _this$ = ecx
; _n$ = eax

; 200  :     {

	push	ebx
	push	esi
	mov	esi, ecx

; 201  :         if(num == n)

	mov	ebx, DWORD PTR [esi+4]
	cmp	ebx, eax
	jne	SHORT $LN4@SetSize

; 202  :             return FALSE;

	pop	esi
	xor	eax, eax
	pop	ebx

; 219  :     }

	ret	0
$LN4@SetSize:

; 203  :         else if(!n)

	test	eax, eax
	jne	SHORT $LN2@SetSize

; 204  :         {
; 205  :             Clear();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN7@SetSize
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 217  : 
; 218  :         return TRUE;

	mov	eax, 1
	pop	ebx

; 219  :     }

	ret	0
$LN2@SetSize:

; 206  :             return TRUE;
; 207  :         }
; 208  : 
; 209  :         BOOL bClear=(n>num);
; 210  :         UINT oldNum=num;
; 211  : 
; 212  :         num = n;
; 213  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	push	edi
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	cmp	ebx, eax
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	sbb	edi, edi
	call	edx
	neg	edi
	mov	DWORD PTR [esi], eax

; 214  : 
; 215  :         if(bClear)

	je	SHORT $LN13@SetSize

; 216  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	ecx, DWORD PTR [esi+4]
	sub	ecx, ebx
	mov	edx, ecx
	shr	ecx, 2
	mov	esi, ecx
	and	edx, 3
	add	ebx, eax
	test	esi, esi
	je	SHORT $LN15@SetSize
	mov	edi, ebx
	xor	eax, eax
	rep stosd
	lea	ebx, DWORD PTR [ebx+esi*4]
$LN15@SetSize:
	test	edx, edx
	je	SHORT $LN13@SetSize
	push	edx
	push	0
	push	ebx
	call	_memset
	add	esp, 12					; 0000000cH
$LN13@SetSize:
	pop	edi

; 204  :         {
; 205  :             Clear();

$LN7@SetSize:

; 217  : 
; 218  :         return TRUE;

	pop	esi
	mov	eax, 1
	pop	ebx

; 219  :     }

	ret	0
?SetSize@?$List@E@@QAEHI@Z ENDP				; List<unsigned char>::SetSize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?AppendArray@?$List@E@@QAEXPBEI@Z
_TEXT	SEGMENT
_new_array$ = 8						; size = 4
?AppendArray@?$List@E@@QAEXPBEI@Z PROC			; List<unsigned char>::AppendArray, COMDAT
; _this$ = esi
; _n$ = ebx

; 178  :     {

	push	ebp
	mov	ebp, esp

; 179  :         if(!new_array && n)

	cmp	DWORD PTR _new_array$[ebp], 0
	jne	SHORT $LN3@AppendArra
	test	ebx, ebx
	je	SHORT $LN4@AppendArra

; 180  :         {
; 181  :             AppWarning(TEXT("List::AppendArray:  NULL array with count above zero"));

	push	OFFSET ??_C@_1GK@FGBPJKAO@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAA?$AAp?$AAp?$AAe?$AAn?$AAd?$AAA?$AAr?$AAr?$AAa?$AAy?$AA?3?$AA?5?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AAa?$AAr?$AAr?$AAa?$AAy?$AA?5?$AAw@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 197  :     }

	pop	ebp
	ret	4
$LN3@AppendArra:

; 182  :             return;
; 183  :         }
; 184  : 
; 185  :         if(!n)

	test	ebx, ebx
	je	SHORT $LN4@AppendArra

; 186  :             return;
; 187  : 
; 188  :         int oldnum = num;

	push	edi
	mov	edi, DWORD PTR [esi+4]

; 189  : 
; 190  :         SetSize(n+num);

	lea	eax, DWORD PTR [edi+ebx]
	mov	ecx, esi
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 191  : 
; 192  :         assert(num);
; 193  : 
; 194  :         if(!num) {array=NULL; return;}

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN1@AppendArra
	mov	DWORD PTR [esi], 0
	pop	edi

; 197  :     }

	pop	ebp
	ret	4
$LN1@AppendArra:

; 195  : 
; 196  :         mcpy(&array[oldnum], (void*)new_array, sizeof(T)*n);

	mov	eax, DWORD PTR _new_array$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	eax
	add	ecx, edi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	edi
$LN4@AppendArra:

; 197  :     }

	pop	ebp
	ret	4
?AppendArray@?$List@E@@QAEXPBEI@Z ENDP			; List<unsigned char>::AppendArray
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?RemoveRange@?$List@E@@QAEXII@Z
_TEXT	SEGMENT
?RemoveRange@?$List@E@@QAEXII@Z PROC			; List<unsigned char>::RemoveRange, COMDAT
; _this$ = eax
; _end$ = ecx

; 107  :     {

	push	esi
	mov	esi, eax

; 108  :         if(start > num || end > num || end <= start)

	cmp	ecx, DWORD PTR [esi+4]
	ja	SHORT $LN5@RemoveRang
	test	ecx, ecx
	je	SHORT $LN5@RemoveRang

; 111  :             return;
; 112  :         }
; 113  : 
; 114  :         UINT count = end-start;
; 115  :         if(count == 1)

	cmp	ecx, 1
	jne	SHORT $LN4@RemoveRang

; 116  :         {
; 117  :             Remove(start);

	call	?Remove@?$List@E@@QAEXI@Z		; List<unsigned char>::Remove
	pop	esi

; 132  :     }

	ret	0
$LN4@RemoveRang:

; 118  :             return;
; 119  :         }
; 120  :         else if(count == num)

	mov	eax, DWORD PTR [esi+4]
	cmp	ecx, eax
	jne	SHORT $LN2@RemoveRang

; 121  :         {
; 122  :             Clear();

	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear
	pop	esi

; 132  :     }

	ret	0
$LN2@RemoveRang:

; 123  :             return;
; 124  :         }
; 125  : 
; 126  :         num -= count;

	sub	eax, ecx
	mov	DWORD PTR [esi+4], eax

; 127  : 
; 128  :         UINT cutoffCount = num-start;
; 129  :         if(cutoffCount)

	je	SHORT $LN1@RemoveRang

; 130  :             mcpy(array+start, array+end, cutoffCount*sizeof(T));

	mov	edx, DWORD PTR [esi]
	push	eax
	lea	eax, DWORD PTR [edx+ecx]
	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN1@RemoveRang:

; 131  :         array = (T*)ReAllocate(array, num*sizeof(T));

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	eax
	call	edx
	mov	DWORD PTR [esi], eax
	pop	esi

; 132  :     }

	ret	0
$LN5@RemoveRang:

; 109  :         {
; 110  :             AppWarning(TEXT("List::RemoveRange:  Invalid range specified."));

	push	OFFSET ??_C@_1FK@OOEEKAAM@?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAR?$AAa?$AAn?$AAg?$AAe?$AA?3?$AA?5?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAr?$AAa?$AAn?$AAg@
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4
	pop	esi

; 132  :     }

	ret	0
?RemoveRange@?$List@E@@QAEXII@Z ENDP			; List<unsigned char>::RemoveRange
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$List@E@@QAE@XZ
_TEXT	SEGMENT
??1?$List@E@@QAE@XZ PROC				; List<unsigned char>::~List<unsigned char>, COMDAT
; _this$ = esi

; 33   :         Clear();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@List@3
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
$LN3@List@3:

; 34   :     }

	ret	0
??1?$List@E@@QAE@XZ ENDP				; List<unsigned char>::~List<unsigned char>
_TEXT	ENDS
PUBLIC	?ReceiveAudio@DeviceAudioSource@@QAEXPAEI@Z	; DeviceAudioSource::ReceiveAudio
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\deviceaudio.cpp
;	COMDAT ?ReceiveAudio@DeviceAudioSource@@QAEXPAEI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_lpData$ = 12						; size = 4
?ReceiveAudio@DeviceAudioSource@@QAEXPAEI@Z PROC	; DeviceAudioSource::ReceiveAudio, COMDAT
; _dataLength$ = ebx

; 109  : {

	push	ebp
	mov	ebp, esp

; 110  :     if(lpData)

	cmp	DWORD PTR _lpData$[ebp], 0
	je	SHORT $LN1@ReceiveAud

; 111  :     {
; 112  :         OSEnterMutex(hAudioMutex);

	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+140]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 113  :         sampleBuffer.AppendArray(lpData, dataLength);

	test	ebx, ebx
	je	SHORT $LN7@ReceiveAud
	push	edi
	mov	edi, DWORD PTR [esi+148]
	lea	eax, DWORD PTR [edi+ebx]
	lea	ecx, DWORD PTR [esi+144]
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize
	cmp	DWORD PTR [esi+148], 0
	jne	SHORT $LN4@ReceiveAud
	mov	DWORD PTR [esi+144], 0
	jmp	SHORT $LN9@ReceiveAud
$LN4@ReceiveAud:
	mov	ecx, DWORD PTR _lpData$[ebp]
	mov	edx, DWORD PTR [esi+144]
	push	ebx
	push	ecx
	add	edx, edi
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@ReceiveAud:
	pop	edi
$LN7@ReceiveAud:

; 114  :         OSLeaveMutex(hAudioMutex);

	mov	eax, esi
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
	pop	esi
$LN1@ReceiveAud:

; 115  :     }
; 116  : }

	pop	ebp
	ret	8
?ReceiveAudio@DeviceAudioSource@@QAEXPAEI@Z ENDP	; DeviceAudioSource::ReceiveAudio
_TEXT	ENDS
PUBLIC	??1DeviceAudioSource@@UAE@XZ			; DeviceAudioSource::~DeviceAudioSource
;	COMDAT xdata$x
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\alloc.h
xdata$x	SEGMENT
__unwindtable$??1DeviceAudioSource@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DeviceAudioSource@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1DeviceAudioSource@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1DeviceAudioSource@@UAE@XZ$2
__ehfuncinfo$??1DeviceAudioSource@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1DeviceAudioSource@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\deviceaudio.cpp
xdata$x	ENDS
;	COMDAT ??1DeviceAudioSource@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1DeviceAudioSource@@UAE@XZ PROC			; DeviceAudioSource::~DeviceAudioSource, COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DeviceAudioSource@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7DeviceAudioSource@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 103  :     if(hAudioMutex)

	mov	eax, DWORD PTR [esi+140]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN1@DeviceAudi

; 104  :         OSCloseMutex(hAudioMutex);

	push	eax
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN1@DeviceAudi:

; 105  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [esi+152]
	cmp	eax, ebx
	je	SHORT $LN9@DeviceAudi
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi+152], ebx
	mov	DWORD PTR [esi+156], ebx
$LN9@DeviceAudi:
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	eax, DWORD PTR [esi+144]
	cmp	eax, ebx
	je	SHORT $LN16@DeviceAudi
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi+144], ebx
	mov	DWORD PTR [esi+148], ebx
$LN16@DeviceAudi:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, esi
	call	DWORD PTR __imp_??1AudioSource@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DeviceAudioSource@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1AudioSource@@UAE@XZ
__unwindfunclet$??1DeviceAudioSource@@UAE@XZ$1:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 144				; 00000090H
	jmp	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
__unwindfunclet$??1DeviceAudioSource@@UAE@XZ$2:
	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 152				; 00000098H
	jmp	??1?$List@E@@QAE@XZ			; List<unsigned char>::~List<unsigned char>
__ehhandler$??1DeviceAudioSource@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DeviceAudioSource@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DeviceAudioSource@@UAE@XZ ENDP			; DeviceAudioSource::~DeviceAudioSource
; Function compile flags: /Ogtp
;	COMDAT ?GetNextBuffer@DeviceAudioSource@@MAE_NPAPAXPAIPA_K@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_numFrames$ = 12					; size = 4
_timestamp$ = 16					; size = 4
?GetNextBuffer@DeviceAudioSource@@MAE_NPAPAXPAIPA_K@Z PROC ; DeviceAudioSource::GetNextBuffer, COMDAT
; _this$ = ecx

; 26   : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 27   :     if(sampleBuffer.Num() >= sampleSegmentSize)

	mov	eax, DWORD PTR [esi+148]
	cmp	eax, DWORD PTR [esi+132]
	jb	$LN1@GetNextBuf

; 28   :     {
; 29   :         OSEnterMutex(hAudioMutex);

	mov	ecx, DWORD PTR [esi+140]
	push	edi
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 30   : 
; 31   :         mcpy(outputBuffer.Array(), sampleBuffer.Array(), sampleSegmentSize);

	mov	edx, DWORD PTR [esi+132]
	mov	eax, DWORD PTR [esi+144]
	mov	ecx, DWORD PTR [esi+152]
	push	edx
	push	eax
	push	ecx
	call	_memcpy

; 32   :         sampleBuffer.RemoveRange(0, sampleSegmentSize);

	mov	ecx, DWORD PTR [esi+132]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [esi+144]
	call	?RemoveRange@?$List@E@@QAEXII@Z		; List<unsigned char>::RemoveRange

; 33   : 
; 34   :         OSLeaveMutex(hAudioMutex);

	mov	edx, DWORD PTR [esi+140]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 35   : 
; 36   :         *buffer = outputBuffer.Array();

	mov	eax, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR [ecx], eax

; 37   :         *numFrames = sampleFrameCount;

	mov	edx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR _numFrames$[ebp]

; 38   :         *timestamp = API->GetAudioTime();

	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	ecx, DWORD PTR _timestamp$[ebp]
	pop	edi
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 39   : 
; 40   :         return true;

	mov	al, 1
	pop	esi

; 44   : }

	pop	ebp
	ret	12					; 0000000cH
$LN1@GetNextBuf:

; 41   :     }
; 42   : 
; 43   :     return false;

	xor	al, al
	pop	esi

; 44   : }

	pop	ebp
	ret	12					; 0000000cH
?GetNextBuffer@DeviceAudioSource@@MAE_NPAPAXPAIPA_K@Z ENDP ; DeviceAudioSource::GetNextBuffer
; Function compile flags: /Ogtp
;	COMDAT ??_GDeviceAudioSource@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GDeviceAudioSource@@UAEPAXI@Z PROC			; DeviceAudioSource::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	esi
	call	??1DeviceAudioSource@@UAE@XZ		; DeviceAudioSource::~DeviceAudioSource
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GDeviceAudioSource@@UAEPAXI@Z ENDP			; DeviceAudioSource::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Initialize@DeviceAudioSource@@QAE_NPAVDeviceSource@@@Z ; DeviceAudioSource::Initialize
; Function compile flags: /Ogtp
;	COMDAT ?Initialize@DeviceAudioSource@@QAE_NPAVDeviceSource@@@Z
_TEXT	SEGMENT
_inputChannels$ = -12					; size = 4
_inputBitsPerSample$ = -8				; size = 4
_bFloat$ = -4						; size = 1
?Initialize@DeviceAudioSource@@QAE_NPAVDeviceSource@@@Z PROC ; DeviceAudioSource::Initialize, COMDAT
; _this$ = esi
; _parent$ = eax

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	edi

; 62   :     device = parent;

	mov	DWORD PTR [esi+128], eax

; 63   :     hAudioMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ

; 64   : 
; 65   :     //---------------------------------
; 66   : 
; 67   :     bool  bFloat = false;
; 68   :     UINT  inputChannels;
; 69   :     UINT  inputSamplesPerSec;
; 70   :     UINT  inputBitsPerSample;
; 71   :     UINT  inputBlockSize;
; 72   :     DWORD inputChannelMask;
; 73   : 
; 74   :     //---------------------------------
; 75   : 
; 76   :     if(device->audioFormat.wFormatTag == WAVE_FORMAT_EXTENSIBLE)

	mov	edi, DWORD PTR [esi+128]
	mov	DWORD PTR [esi+140], eax
	movzx	eax, WORD PTR [edi+32]
	mov	ecx, 65534				; 0000fffeH
	mov	BYTE PTR _bFloat$[ebp], 0
	cmp	ax, cx
	jne	SHORT $LN4@Initialize

; 77   :     {
; 78   :         WAVEFORMATEXTENSIBLE *wfext = (WAVEFORMATEXTENSIBLE*)&device->audioFormat;
; 79   :         if(wfext->SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)

	lea	edx, DWORD PTR [edi+56]
	mov	ecx, OFFSET __GUID_00000003_0000_0010_8000_00aa00389b71
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN1@Initialize

; 80   :             bFloat = true;
; 81   :     }

	jmp	SHORT $LN9@Initialize
$LN4@Initialize:

; 82   :     else if(device->audioFormat.wFormatTag == WAVE_FORMAT_IEEE_FLOAT)

	cmp	eax, 3
	jne	SHORT $LN1@Initialize
$LN9@Initialize:

; 83   :         bFloat = true;

	mov	BYTE PTR _bFloat$[ebp], 1
$LN1@Initialize:

; 84   : 
; 85   :     inputBitsPerSample = device->audioFormat.wBitsPerSample;
; 86   :     inputBlockSize     = device->audioFormat.nBlockAlign;
; 87   :     inputChannelMask   = 0;
; 88   :     inputChannels      = device->audioFormat.nChannels;

	movzx	eax, WORD PTR [edi+34]
	movzx	edx, WORD PTR [edi+46]
	movzx	ebx, WORD PTR [edi+44]

; 89   :     inputSamplesPerSec = device->audioFormat.nSamplesPerSec;

	mov	edi, DWORD PTR [edi+36]
	mov	DWORD PTR _inputChannels$[ebp], eax
	mov	DWORD PTR _inputBitsPerSample$[ebp], edx

; 90   : 
; 91   :     sampleFrameCount   = inputSamplesPerSec/100;

	mov	eax, 1374389535				; 51eb851fH
	mul	edi
	shr	edx, 5

; 92   :     sampleSegmentSize  = inputBlockSize*sampleFrameCount;

	mov	eax, edx
	imul	eax, ebx

; 93   : 
; 94   :     outputBuffer.SetSize(sampleSegmentSize);

	lea	ecx, DWORD PTR [esi+152]
	mov	DWORD PTR [esi+136], edx
	mov	DWORD PTR [esi+132], eax
	call	?SetSize@?$List@E@@QAEHI@Z		; List<unsigned char>::SetSize

; 95   : 
; 96   :     InitAudioData(bFloat, inputChannels, inputSamplesPerSec, inputBitsPerSample, inputBlockSize, inputChannelMask);

	mov	ecx, DWORD PTR _inputBitsPerSample$[ebp]
	mov	edx, DWORD PTR _inputChannels$[ebp]
	mov	eax, DWORD PTR _bFloat$[ebp]
	push	0
	push	ebx
	push	ecx
	push	edi
	push	edx
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?InitAudioData@AudioSource@@IAEX_NIIIIK@Z
	pop	edi

; 97   : 
; 98   :     return true;

	mov	al, 1
	pop	ebx

; 99   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Initialize@DeviceAudioSource@@QAE_NPAVDeviceSource@@@Z ENDP ; DeviceAudioSource::Initialize
END
