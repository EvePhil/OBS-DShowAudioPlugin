; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\beeanyew\Documents\GitHub\OBS\DShowAudioPlugin\CaptureFilter.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z	; CaptureEnumPins::Clone
PUBLIC	?Reset@CaptureEnumPins@@UAGJXZ			; CaptureEnumPins::Reset
PUBLIC	?Skip@CaptureEnumPins@@UAGJK@Z			; CaptureEnumPins::Skip
PUBLIC	?Next@CaptureEnumPins@@UAGJKPAPAUIPin@@PAK@Z	; CaptureEnumPins::Next
PUBLIC	?Release@CaptureEnumPins@@UAGKXZ		; CaptureEnumPins::Release
PUBLIC	?AddRef@CaptureEnumPins@@UAGKXZ			; CaptureEnumPins::AddRef
PUBLIC	?QueryInterface@CaptureEnumPins@@UAGJABU_GUID@@PAPAX@Z ; CaptureEnumPins::QueryInterface
PUBLIC	??_R4CaptureEnumPins@@6B@			; CaptureEnumPins::`RTTI Complete Object Locator'
PUBLIC	??_R3CaptureEnumPins@@8				; CaptureEnumPins::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CaptureEnumPins@@8				; CaptureEnumPins::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IEnumPins@@8			; IEnumPins::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IEnumPins@@8				; IEnumPins::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IEnumPins@@8				; IEnumPins::`RTTI Base Class Array'
PUBLIC	??_R0?AUIEnumPins@@@8				; IEnumPins `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CaptureEnumPins@@8		; CaptureEnumPins::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCaptureEnumPins@@@8			; CaptureEnumPins `RTTI Type Descriptor'
PUBLIC	?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z ; CaptureEnumMediaTypes::Clone
PUBLIC	?Reset@CaptureEnumMediaTypes@@UAGJXZ		; CaptureEnumMediaTypes::Reset
PUBLIC	?Skip@CaptureEnumMediaTypes@@UAGJK@Z		; CaptureEnumMediaTypes::Skip
PUBLIC	?Next@CaptureEnumMediaTypes@@UAGJKPAPAU_AMMediaType@@PAK@Z ; CaptureEnumMediaTypes::Next
PUBLIC	?Release@CaptureEnumMediaTypes@@UAGKXZ		; CaptureEnumMediaTypes::Release
PUBLIC	?AddRef@CaptureEnumMediaTypes@@UAGKXZ		; CaptureEnumMediaTypes::AddRef
PUBLIC	?QueryInterface@CaptureEnumMediaTypes@@UAGJABU_GUID@@PAPAX@Z ; CaptureEnumMediaTypes::QueryInterface
PUBLIC	??_R4CaptureEnumMediaTypes@@6B@			; CaptureEnumMediaTypes::`RTTI Complete Object Locator'
PUBLIC	??_R3CaptureEnumMediaTypes@@8			; CaptureEnumMediaTypes::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CaptureEnumMediaTypes@@8			; CaptureEnumMediaTypes::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IEnumMediaTypes@@8		; IEnumMediaTypes::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IEnumMediaTypes@@8				; IEnumMediaTypes::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IEnumMediaTypes@@8				; IEnumMediaTypes::`RTTI Base Class Array'
PUBLIC	??_R0?AUIEnumMediaTypes@@@8			; IEnumMediaTypes `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CaptureEnumMediaTypes@@8		; CaptureEnumMediaTypes::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCaptureEnumMediaTypes@@@8		; CaptureEnumMediaTypes `RTTI Type Descriptor'
PUBLIC	?ReceiveCanBlock@CapturePin@@UAGJXZ		; CapturePin::ReceiveCanBlock
PUBLIC	?ReceiveMultiple@CapturePin@@UAGJPAPAUIMediaSample@@JPAJ@Z ; CapturePin::ReceiveMultiple
PUBLIC	?Receive@CapturePin@@UAGJPAUIMediaSample@@@Z	; CapturePin::Receive
PUBLIC	?GetAllocatorRequirements@CapturePin@@UAGJPAU_AllocatorProperties@@@Z ; CapturePin::GetAllocatorRequirements
PUBLIC	?NotifyAllocator@CapturePin@@UAGJPAUIMemAllocator@@H@Z ; CapturePin::NotifyAllocator
PUBLIC	?GetAllocator@CapturePin@@UAGJPAPAUIMemAllocator@@@Z ; CapturePin::GetAllocator
PUBLIC	??_R4CapturePin@@6BIMemInputPin@@@		; CapturePin::`RTTI Complete Object Locator'
PUBLIC	?NewSegment@CapturePin@@UAGJ_J0N@Z		; CapturePin::NewSegment
PUBLIC	?EndFlush@CapturePin@@UAGJXZ			; CapturePin::EndFlush
PUBLIC	?BeginFlush@CapturePin@@UAGJXZ			; CapturePin::BeginFlush
PUBLIC	?EndOfStream@CapturePin@@UAGJXZ			; CapturePin::EndOfStream
PUBLIC	?QueryInternalConnections@CapturePin@@UAGJPAPAUIPin@@PAK@Z ; CapturePin::QueryInternalConnections
PUBLIC	?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z ; CapturePin::EnumMediaTypes
PUBLIC	?QueryAccept@CapturePin@@UAGJPBU_AMMediaType@@@Z ; CapturePin::QueryAccept
PUBLIC	?QueryId@CapturePin@@UAGJPAPA_W@Z		; CapturePin::QueryId
PUBLIC	?QueryDirection@CapturePin@@UAGJPAW4_PinDirection@@@Z ; CapturePin::QueryDirection
PUBLIC	?QueryPinInfo@CapturePin@@UAGJPAU_PinInfo@@@Z	; CapturePin::QueryPinInfo
PUBLIC	?ConnectionMediaType@CapturePin@@UAGJPAU_AMMediaType@@@Z ; CapturePin::ConnectionMediaType
PUBLIC	?ConnectedTo@CapturePin@@UAGJPAPAUIPin@@@Z	; CapturePin::ConnectedTo
PUBLIC	?Disconnect@CapturePin@@UAGJXZ			; CapturePin::Disconnect
PUBLIC	?ReceiveConnection@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z ; CapturePin::ReceiveConnection
PUBLIC	?Connect@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z ; CapturePin::Connect
PUBLIC	?Release@CapturePin@@UAGKXZ			; CapturePin::Release
PUBLIC	?AddRef@CapturePin@@UAGKXZ			; CapturePin::AddRef
PUBLIC	?QueryInterface@CapturePin@@UAGJABU_GUID@@PAPAX@Z ; CapturePin::QueryInterface
PUBLIC	??_R4CapturePin@@6BIPin@@@			; CapturePin::`RTTI Complete Object Locator'
PUBLIC	??_R3CapturePin@@8				; CapturePin::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CapturePin@@8				; CapturePin::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R13?0A@EA@IMemInputPin@@8			; IMemInputPin::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R3IMemInputPin@@8				; IMemInputPin::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IMemInputPin@@8				; IMemInputPin::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IMemInputPin@@8			; IMemInputPin::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIMemInputPin@@@8			; IMemInputPin `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
PUBLIC	??_R1A@?0A@EA@IPin@@8				; IPin::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IPin@@8					; IPin::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IPin@@8					; IPin::`RTTI Base Class Array'
PUBLIC	??_R0?AUIPin@@@8				; IPin `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CapturePin@@8			; CapturePin::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCapturePin@@@8				; CapturePin `RTTI Type Descriptor'
PUBLIC	?QueryVendorInfo@CaptureFilter@@UAGJPAPA_W@Z	; CaptureFilter::QueryVendorInfo
PUBLIC	?JoinFilterGraph@CaptureFilter@@UAGJPAUIFilterGraph@@PB_W@Z ; CaptureFilter::JoinFilterGraph
PUBLIC	?QueryFilterInfo@CaptureFilter@@UAGJPAU_FilterInfo@@@Z ; CaptureFilter::QueryFilterInfo
PUBLIC	?FindPin@CaptureFilter@@UAGJPB_WPAPAUIPin@@@Z	; CaptureFilter::FindPin
PUBLIC	?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z	; CaptureFilter::EnumPins
PUBLIC	?GetSyncSource@CaptureFilter@@UAGJPAPAUIReferenceClock@@@Z ; CaptureFilter::GetSyncSource
PUBLIC	?SetSyncSource@CaptureFilter@@UAGJPAUIReferenceClock@@@Z ; CaptureFilter::SetSyncSource
PUBLIC	?GetState@CaptureFilter@@UAGJKPAW4_FilterState@@@Z ; CaptureFilter::GetState
PUBLIC	?Run@CaptureFilter@@UAGJ_J@Z			; CaptureFilter::Run
PUBLIC	?Pause@CaptureFilter@@UAGJXZ			; CaptureFilter::Pause
PUBLIC	?Stop@CaptureFilter@@UAGJXZ			; CaptureFilter::Stop
PUBLIC	?GetClassID@CaptureFilter@@UAGJPAU_GUID@@@Z	; CaptureFilter::GetClassID
PUBLIC	?Release@CaptureFilter@@UAGKXZ			; CaptureFilter::Release
PUBLIC	?AddRef@CaptureFilter@@UAGKXZ			; CaptureFilter::AddRef
PUBLIC	?QueryInterface@CaptureFilter@@UAGJABU_GUID@@PAPAX@Z ; CaptureFilter::QueryInterface
PUBLIC	??_R4CaptureFilter@@6B@				; CaptureFilter::`RTTI Complete Object Locator'
PUBLIC	??_R3CaptureFilter@@8				; CaptureFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CaptureFilter@@8				; CaptureFilter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IBaseFilter@@8			; IBaseFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IBaseFilter@@8				; IBaseFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IBaseFilter@@8				; IBaseFilter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IMediaFilter@@8			; IMediaFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IMediaFilter@@8				; IMediaFilter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IMediaFilter@@8				; IMediaFilter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IPersist@@8			; IPersist::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IPersist@@8				; IPersist::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IPersist@@8				; IPersist::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R0?AUIPersist@@@8				; IPersist `RTTI Type Descriptor'
PUBLIC	??_R0?AUIMediaFilter@@@8			; IMediaFilter `RTTI Type Descriptor'
PUBLIC	??_R0?AUIBaseFilter@@@8				; IBaseFilter `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@CaptureFilter@@8			; CaptureFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCaptureFilter@@@8			; CaptureFilter `RTTI Type Descriptor'
PUBLIC	?zero@@YGXPAXI@Z				; zero
PUBLIC	??0IPin@@QAE@XZ					; IPin::IPin
PUBLIC	??0IMemInputPin@@QAE@XZ				; IMemInputPin::IMemInputPin
PUBLIC	??_GCapturePin@@UAEPAXI@Z			; CapturePin::`scalar deleting destructor'
PUBLIC	?QueryInterface@CapturePin@@W3AGJABU_GUID@@PAPAX@Z ; [thunk]:CapturePin::QueryInterface`adjustor{4}'
PUBLIC	?AddRef@CapturePin@@W3AGKXZ			; [thunk]:CapturePin::AddRef`adjustor{4}'
PUBLIC	?Release@CapturePin@@W3AGKXZ			; [thunk]:CapturePin::Release`adjustor{4}'
PUBLIC	?Release@SampleData@@QAEXXZ			; SampleData::Release
PUBLIC	??1SampleData@@QAE@XZ				; SampleData::~SampleData
PUBLIC	??_GSampleData@@QAEPAXI@Z			; SampleData::`scalar deleting destructor'
PUBLIC	?Num@?$List@PAUSampleData@@@@QBEIXZ		; List<SampleData *>::Num
PUBLIC	?Free@@YAXPAX@Z					; Free
PUBLIC	?Clear@?$List@PAUSampleData@@@@QAEXXZ		; List<SampleData *>::Clear
PUBLIC	??A?$List@PAUSampleData@@@@QAEAAPAUSampleData@@I@Z ; List<SampleData *>::operator[]
PUBLIC	?FlushSamples@DeviceSource@@AAEXXZ		; DeviceSource::FlushSamples
PUBLIC	_!=
PUBLIC	??0IPersist@@QAE@XZ				; IPersist::IPersist
PUBLIC	??0IMediaFilter@@QAE@XZ				; IMediaFilter::IMediaFilter
PUBLIC	??0IBaseFilter@@QAE@XZ				; IBaseFilter::IBaseFilter
PUBLIC	??_GCaptureFilter@@UAEPAXI@Z			; CaptureFilter::`scalar deleting destructor'
PUBLIC	??0IEnumPins@@QAE@XZ				; IEnumPins::IEnumPins
PUBLIC	??_GCaptureEnumPins@@UAEPAXI@Z			; CaptureEnumPins::`scalar deleting destructor'
PUBLIC	?GetCapturePin@CaptureFilter@@QBEPAVCapturePin@@XZ ; CaptureFilter::GetCapturePin
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
PUBLIC	??0IEnumMediaTypes@@QAE@XZ			; IEnumMediaTypes::IEnumMediaTypes
PUBLIC	??_GCaptureEnumMediaTypes@@UAEPAXI@Z		; CaptureEnumMediaTypes::`scalar deleting destructor'
PUBLIC	_IsEqualGUID
PUBLIC	_==
PUBLIC	_WinbaseIsolationAwarePrivateT_UnPgpgk
PUBLIC	_IsolationAwarePrivateT_SqbjaYRiRY
PUBLIC	_WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
PUBLIC	_WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
PUBLIC	??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_R0PAUSampleData@@@8				; SampleData * `RTTI Type Descriptor'
PUBLIC	??_7CaptureFilter@@6B@				; CaptureFilter::`vftable'
PUBLIC	??_7CapturePin@@6BIPin@@@			; CapturePin::`vftable'
PUBLIC	??_7CapturePin@@6BIMemInputPin@@@		; CapturePin::`vftable'
PUBLIC	??_7CaptureEnumMediaTypes@@6B@			; CaptureEnumMediaTypes::`vftable'
PUBLIC	??_7CaptureEnumPins@@6B@			; CaptureEnumPins::`vftable'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_ECapturePin@@UAEPAXI@Z:PROC			; CapturePin::`vector deleting destructor'
EXTRN	_IID_IPin:BYTE
EXTRN	_IID_IMemInputPin:BYTE
EXTRN	_GUID_NULL:BYTE
EXTRN	__imp_?OSEnterMutex@@YGXPAX@Z:PROC
EXTRN	__imp_?OSLeaveMutex@@YGXPAX@Z:PROC
EXTRN	__imp_?MainAllocator@@3PAVAlloc@@A:DWORD
EXTRN	?__type_info_root_node@@3U__type_info_node@@A:QWORD ; __type_info_root_node
EXTRN	?name@type_info@@QBEPBDPAU__type_info_node@@@Z:PROC ; type_info::name
EXTRN	__imp_?CrashError@@YAXPB_WZZ:PROC
EXTRN	_MEDIATYPE_Audio:BYTE
EXTRN	_MEDIATYPE_Video:BYTE
EXTRN	??_ECaptureFilter@@UAEPAXI@Z:PROC		; CaptureFilter::`vector deleting destructor'
EXTRN	_IID_IPersist:BYTE
EXTRN	_IID_IMediaFilter:BYTE
EXTRN	_IID_IBaseFilter:BYTE
EXTRN	??_ECaptureEnumPins@@UAEPAXI@Z:PROC		; CaptureEnumPins::`vector deleting destructor'
EXTRN	_IID_IEnumPins:BYTE
EXTRN	??_ECaptureEnumMediaTypes@@UAEPAXI@Z:PROC	; CaptureEnumMediaTypes::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IEnumMediaTypes:BYTE
EXTRN	__imp__InterlockedDecrement@4:PROC
;	COMDAT _IsolationAwarePrivateT_SqbjaYRiRY
_BSS	SEGMENT
_IsolationAwarePrivateT_SqbjaYRiRY DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk
_BSS	SEGMENT
_WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ
_BSS	SEGMENT
_WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ DD 01H DUP (?)
;	COMDAT ??_7CaptureEnumPins@@6B@
CONST	SEGMENT
??_7CaptureEnumPins@@6B@ DD FLAT:??_R4CaptureEnumPins@@6B@ ; CaptureEnumPins::`vftable'
	DD	FLAT:?QueryInterface@CaptureEnumPins@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CaptureEnumPins@@UAGKXZ
	DD	FLAT:?Release@CaptureEnumPins@@UAGKXZ
	DD	FLAT:?Next@CaptureEnumPins@@UAGJKPAPAUIPin@@PAK@Z
	DD	FLAT:?Skip@CaptureEnumPins@@UAGJK@Z
	DD	FLAT:?Reset@CaptureEnumPins@@UAGJXZ
	DD	FLAT:?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z
	DD	FLAT:??_ECaptureEnumPins@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CaptureEnumPins@@6B@
rdata$r	SEGMENT
??_R4CaptureEnumPins@@6B@ DD 00H			; CaptureEnumPins::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCaptureEnumPins@@@8
	DD	FLAT:??_R3CaptureEnumPins@@8
rdata$r	ENDS
;	COMDAT ??_R3CaptureEnumPins@@8
rdata$r	SEGMENT
??_R3CaptureEnumPins@@8 DD 00H				; CaptureEnumPins::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CaptureEnumPins@@8
rdata$r	ENDS
;	COMDAT ??_R2CaptureEnumPins@@8
rdata$r	SEGMENT
??_R2CaptureEnumPins@@8 DD FLAT:??_R1A@?0A@EA@CaptureEnumPins@@8 ; CaptureEnumPins::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IEnumPins@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IEnumPins@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IEnumPins@@8 DD FLAT:??_R0?AUIEnumPins@@@8 ; IEnumPins::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IEnumPins@@8
rdata$r	ENDS
;	COMDAT ??_R3IEnumPins@@8
rdata$r	SEGMENT
??_R3IEnumPins@@8 DD 00H				; IEnumPins::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IEnumPins@@8
rdata$r	ENDS
;	COMDAT ??_R2IEnumPins@@8
rdata$r	SEGMENT
??_R2IEnumPins@@8 DD FLAT:??_R1A@?0A@EA@IEnumPins@@8	; IEnumPins::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIEnumPins@@@8
_DATA	SEGMENT
??_R0?AUIEnumPins@@@8 DD FLAT:??_7type_info@@6B@	; IEnumPins `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIEnumPins@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CaptureEnumPins@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CaptureEnumPins@@8 DD FLAT:??_R0?AVCaptureEnumPins@@@8 ; CaptureEnumPins::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CaptureEnumPins@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCaptureEnumPins@@@8
_DATA	SEGMENT
??_R0?AVCaptureEnumPins@@@8 DD FLAT:??_7type_info@@6B@	; CaptureEnumPins `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCaptureEnumPins@@', 00H
_DATA	ENDS
;	COMDAT ??_7CaptureEnumMediaTypes@@6B@
CONST	SEGMENT
??_7CaptureEnumMediaTypes@@6B@ DD FLAT:??_R4CaptureEnumMediaTypes@@6B@ ; CaptureEnumMediaTypes::`vftable'
	DD	FLAT:?QueryInterface@CaptureEnumMediaTypes@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CaptureEnumMediaTypes@@UAGKXZ
	DD	FLAT:?Release@CaptureEnumMediaTypes@@UAGKXZ
	DD	FLAT:?Next@CaptureEnumMediaTypes@@UAGJKPAPAU_AMMediaType@@PAK@Z
	DD	FLAT:?Skip@CaptureEnumMediaTypes@@UAGJK@Z
	DD	FLAT:?Reset@CaptureEnumMediaTypes@@UAGJXZ
	DD	FLAT:?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z
	DD	FLAT:??_ECaptureEnumMediaTypes@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CaptureEnumMediaTypes@@6B@
rdata$r	SEGMENT
??_R4CaptureEnumMediaTypes@@6B@ DD 00H			; CaptureEnumMediaTypes::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCaptureEnumMediaTypes@@@8
	DD	FLAT:??_R3CaptureEnumMediaTypes@@8
rdata$r	ENDS
;	COMDAT ??_R3CaptureEnumMediaTypes@@8
rdata$r	SEGMENT
??_R3CaptureEnumMediaTypes@@8 DD 00H			; CaptureEnumMediaTypes::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CaptureEnumMediaTypes@@8
rdata$r	ENDS
;	COMDAT ??_R2CaptureEnumMediaTypes@@8
rdata$r	SEGMENT
??_R2CaptureEnumMediaTypes@@8 DD FLAT:??_R1A@?0A@EA@CaptureEnumMediaTypes@@8 ; CaptureEnumMediaTypes::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IEnumMediaTypes@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IEnumMediaTypes@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IEnumMediaTypes@@8 DD FLAT:??_R0?AUIEnumMediaTypes@@@8 ; IEnumMediaTypes::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IEnumMediaTypes@@8
rdata$r	ENDS
;	COMDAT ??_R3IEnumMediaTypes@@8
rdata$r	SEGMENT
??_R3IEnumMediaTypes@@8 DD 00H				; IEnumMediaTypes::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IEnumMediaTypes@@8
rdata$r	ENDS
;	COMDAT ??_R2IEnumMediaTypes@@8
rdata$r	SEGMENT
??_R2IEnumMediaTypes@@8 DD FLAT:??_R1A@?0A@EA@IEnumMediaTypes@@8 ; IEnumMediaTypes::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIEnumMediaTypes@@@8
_DATA	SEGMENT
??_R0?AUIEnumMediaTypes@@@8 DD FLAT:??_7type_info@@6B@	; IEnumMediaTypes `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIEnumMediaTypes@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CaptureEnumMediaTypes@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CaptureEnumMediaTypes@@8 DD FLAT:??_R0?AVCaptureEnumMediaTypes@@@8 ; CaptureEnumMediaTypes::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CaptureEnumMediaTypes@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCaptureEnumMediaTypes@@@8
_DATA	SEGMENT
??_R0?AVCaptureEnumMediaTypes@@@8 DD FLAT:??_7type_info@@6B@ ; CaptureEnumMediaTypes `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCaptureEnumMediaTypes@@', 00H
_DATA	ENDS
;	COMDAT ??_7CapturePin@@6BIMemInputPin@@@
CONST	SEGMENT
??_7CapturePin@@6BIMemInputPin@@@ DD FLAT:??_R4CapturePin@@6BIMemInputPin@@@ ; CapturePin::`vftable'
	DD	FLAT:?QueryInterface@CapturePin@@W3AGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CapturePin@@W3AGKXZ
	DD	FLAT:?Release@CapturePin@@W3AGKXZ
	DD	FLAT:?GetAllocator@CapturePin@@UAGJPAPAUIMemAllocator@@@Z
	DD	FLAT:?NotifyAllocator@CapturePin@@UAGJPAUIMemAllocator@@H@Z
	DD	FLAT:?GetAllocatorRequirements@CapturePin@@UAGJPAU_AllocatorProperties@@@Z
	DD	FLAT:?Receive@CapturePin@@UAGJPAUIMediaSample@@@Z
	DD	FLAT:?ReceiveMultiple@CapturePin@@UAGJPAPAUIMediaSample@@JPAJ@Z
	DD	FLAT:?ReceiveCanBlock@CapturePin@@UAGJXZ
CONST	ENDS
;	COMDAT ??_R4CapturePin@@6BIMemInputPin@@@
rdata$r	SEGMENT
??_R4CapturePin@@6BIMemInputPin@@@ DD 00H		; CapturePin::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCapturePin@@@8
	DD	FLAT:??_R3CapturePin@@8
rdata$r	ENDS
;	COMDAT ??_7CapturePin@@6BIPin@@@
CONST	SEGMENT
??_7CapturePin@@6BIPin@@@ DD FLAT:??_R4CapturePin@@6BIPin@@@ ; CapturePin::`vftable'
	DD	FLAT:?QueryInterface@CapturePin@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CapturePin@@UAGKXZ
	DD	FLAT:?Release@CapturePin@@UAGKXZ
	DD	FLAT:?Connect@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z
	DD	FLAT:?ReceiveConnection@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z
	DD	FLAT:?Disconnect@CapturePin@@UAGJXZ
	DD	FLAT:?ConnectedTo@CapturePin@@UAGJPAPAUIPin@@@Z
	DD	FLAT:?ConnectionMediaType@CapturePin@@UAGJPAU_AMMediaType@@@Z
	DD	FLAT:?QueryPinInfo@CapturePin@@UAGJPAU_PinInfo@@@Z
	DD	FLAT:?QueryDirection@CapturePin@@UAGJPAW4_PinDirection@@@Z
	DD	FLAT:?QueryId@CapturePin@@UAGJPAPA_W@Z
	DD	FLAT:?QueryAccept@CapturePin@@UAGJPBU_AMMediaType@@@Z
	DD	FLAT:?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z
	DD	FLAT:?QueryInternalConnections@CapturePin@@UAGJPAPAUIPin@@PAK@Z
	DD	FLAT:?EndOfStream@CapturePin@@UAGJXZ
	DD	FLAT:?BeginFlush@CapturePin@@UAGJXZ
	DD	FLAT:?EndFlush@CapturePin@@UAGJXZ
	DD	FLAT:?NewSegment@CapturePin@@UAGJ_J0N@Z
	DD	FLAT:??_ECapturePin@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CapturePin@@6BIPin@@@
rdata$r	SEGMENT
??_R4CapturePin@@6BIPin@@@ DD 00H			; CapturePin::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCapturePin@@@8
	DD	FLAT:??_R3CapturePin@@8
rdata$r	ENDS
;	COMDAT ??_R3CapturePin@@8
rdata$r	SEGMENT
??_R3CapturePin@@8 DD 00H				; CapturePin::`RTTI Class Hierarchy Descriptor'
	DD	05H
	DD	05H
	DD	FLAT:??_R2CapturePin@@8
rdata$r	ENDS
;	COMDAT ??_R2CapturePin@@8
rdata$r	SEGMENT
??_R2CapturePin@@8 DD FLAT:??_R1A@?0A@EA@CapturePin@@8	; CapturePin::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IPin@@8
	DD	FLAT:??_R1A@?0A@EC@IUnknown@@8
	DD	FLAT:??_R13?0A@EA@IMemInputPin@@8
	DD	FLAT:??_R13?0A@EC@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R13?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@IMemInputPin@@8
rdata$r	SEGMENT
??_R13?0A@EA@IMemInputPin@@8 DD FLAT:??_R0?AUIMemInputPin@@@8 ; IMemInputPin::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IMemInputPin@@8
rdata$r	ENDS
;	COMDAT ??_R3IMemInputPin@@8
rdata$r	SEGMENT
??_R3IMemInputPin@@8 DD 00H				; IMemInputPin::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IMemInputPin@@8
rdata$r	ENDS
;	COMDAT ??_R2IMemInputPin@@8
rdata$r	SEGMENT
??_R2IMemInputPin@@8 DD FLAT:??_R1A@?0A@EA@IMemInputPin@@8 ; IMemInputPin::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IMemInputPin@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IMemInputPin@@8 DD FLAT:??_R0?AUIMemInputPin@@@8 ; IMemInputPin::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IMemInputPin@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIMemInputPin@@@8
_DATA	SEGMENT
??_R0?AUIMemInputPin@@@8 DD FLAT:??_7type_info@@6B@	; IMemInputPin `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIMemInputPin@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IPin@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IPin@@8 DD FLAT:??_R0?AUIPin@@@8		; IPin::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IPin@@8
rdata$r	ENDS
;	COMDAT ??_R3IPin@@8
rdata$r	SEGMENT
??_R3IPin@@8 DD	00H					; IPin::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IPin@@8
rdata$r	ENDS
;	COMDAT ??_R2IPin@@8
rdata$r	SEGMENT
??_R2IPin@@8 DD	FLAT:??_R1A@?0A@EA@IPin@@8		; IPin::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIPin@@@8
_DATA	SEGMENT
??_R0?AUIPin@@@8 DD FLAT:??_7type_info@@6B@		; IPin `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIPin@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CapturePin@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CapturePin@@8 DD FLAT:??_R0?AVCapturePin@@@8 ; CapturePin::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CapturePin@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCapturePin@@@8
_DATA	SEGMENT
??_R0?AVCapturePin@@@8 DD FLAT:??_7type_info@@6B@	; CapturePin `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCapturePin@@', 00H
_DATA	ENDS
;	COMDAT ??_7CaptureFilter@@6B@
CONST	SEGMENT
??_7CaptureFilter@@6B@ DD FLAT:??_R4CaptureFilter@@6B@	; CaptureFilter::`vftable'
	DD	FLAT:?QueryInterface@CaptureFilter@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CaptureFilter@@UAGKXZ
	DD	FLAT:?Release@CaptureFilter@@UAGKXZ
	DD	FLAT:?GetClassID@CaptureFilter@@UAGJPAU_GUID@@@Z
	DD	FLAT:?Stop@CaptureFilter@@UAGJXZ
	DD	FLAT:?Pause@CaptureFilter@@UAGJXZ
	DD	FLAT:?Run@CaptureFilter@@UAGJ_J@Z
	DD	FLAT:?GetState@CaptureFilter@@UAGJKPAW4_FilterState@@@Z
	DD	FLAT:?SetSyncSource@CaptureFilter@@UAGJPAUIReferenceClock@@@Z
	DD	FLAT:?GetSyncSource@CaptureFilter@@UAGJPAPAUIReferenceClock@@@Z
	DD	FLAT:?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z
	DD	FLAT:?FindPin@CaptureFilter@@UAGJPB_WPAPAUIPin@@@Z
	DD	FLAT:?QueryFilterInfo@CaptureFilter@@UAGJPAU_FilterInfo@@@Z
	DD	FLAT:?JoinFilterGraph@CaptureFilter@@UAGJPAUIFilterGraph@@PB_W@Z
	DD	FLAT:?QueryVendorInfo@CaptureFilter@@UAGJPAPA_W@Z
	DD	FLAT:??_ECaptureFilter@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4CaptureFilter@@6B@
rdata$r	SEGMENT
??_R4CaptureFilter@@6B@ DD 00H				; CaptureFilter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCaptureFilter@@@8
	DD	FLAT:??_R3CaptureFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3CaptureFilter@@8
rdata$r	SEGMENT
??_R3CaptureFilter@@8 DD 00H				; CaptureFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CaptureFilter@@8
rdata$r	ENDS
;	COMDAT ??_R2CaptureFilter@@8
rdata$r	SEGMENT
??_R2CaptureFilter@@8 DD FLAT:??_R1A@?0A@EA@CaptureFilter@@8 ; CaptureFilter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IBaseFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IMediaFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IPersist@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IBaseFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IBaseFilter@@8 DD FLAT:??_R0?AUIBaseFilter@@@8 ; IBaseFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IBaseFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3IBaseFilter@@8
rdata$r	SEGMENT
??_R3IBaseFilter@@8 DD 00H				; IBaseFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2IBaseFilter@@8
rdata$r	ENDS
;	COMDAT ??_R2IBaseFilter@@8
rdata$r	SEGMENT
??_R2IBaseFilter@@8 DD FLAT:??_R1A@?0A@EA@IBaseFilter@@8 ; IBaseFilter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IMediaFilter@@8
	DD	FLAT:??_R1A@?0A@EA@IPersist@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IMediaFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IMediaFilter@@8 DD FLAT:??_R0?AUIMediaFilter@@@8 ; IMediaFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IMediaFilter@@8
rdata$r	ENDS
;	COMDAT ??_R3IMediaFilter@@8
rdata$r	SEGMENT
??_R3IMediaFilter@@8 DD 00H				; IMediaFilter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2IMediaFilter@@8
rdata$r	ENDS
;	COMDAT ??_R2IMediaFilter@@8
rdata$r	SEGMENT
??_R2IMediaFilter@@8 DD FLAT:??_R1A@?0A@EA@IMediaFilter@@8 ; IMediaFilter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IPersist@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IPersist@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IPersist@@8 DD FLAT:??_R0?AUIPersist@@@8	; IPersist::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IPersist@@8
rdata$r	ENDS
;	COMDAT ??_R3IPersist@@8
rdata$r	SEGMENT
??_R3IPersist@@8 DD 00H					; IPersist::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IPersist@@8
rdata$r	ENDS
;	COMDAT ??_R2IPersist@@8
rdata$r	SEGMENT
??_R2IPersist@@8 DD FLAT:??_R1A@?0A@EA@IPersist@@8	; IPersist::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
_DATA	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AUIPersist@@@8
_DATA	SEGMENT
??_R0?AUIPersist@@@8 DD FLAT:??_7type_info@@6B@		; IPersist `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIPersist@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AUIMediaFilter@@@8
_DATA	SEGMENT
??_R0?AUIMediaFilter@@@8 DD FLAT:??_7type_info@@6B@	; IMediaFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIMediaFilter@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AUIBaseFilter@@@8
_DATA	SEGMENT
??_R0?AUIBaseFilter@@@8 DD FLAT:??_7type_info@@6B@	; IBaseFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIBaseFilter@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CaptureFilter@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CaptureFilter@@8 DD FLAT:??_R0?AVCaptureFilter@@@8 ; CaptureFilter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CaptureFilter@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCaptureFilter@@@8
_DATA	SEGMENT
??_R0?AVCaptureFilter@@@8 DD FLAT:??_7type_info@@6B@	; CaptureFilter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCaptureFilter@@', 00H
_DATA	ENDS
;	COMDAT ??_R0PAUSampleData@@@8
_DATA	SEGMENT
??_R0PAUSampleData@@@8 DD FLAT:??_7type_info@@6B@	; SampleData * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAUSampleData@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@ DB 'O'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '!', 00H, ' '
	DB	00H, ' ', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '<', 00H
	DB	'%', 00H, 'S', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'[', 00H, ']', 00H, '(', 00H, '%', 00H, 'd', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT _WinbaseIsolationAwarePrivateT_UnPgpgk
_DATA	SEGMENT
_WinbaseIsolationAwarePrivateT_UnPgpgk DD 0ffffffffH
$SG-321	DB	00H
	ORG $+2
$SG-322	DB	00H, 00H
	ORG $+2
$SG-340	DB	'M', 00H, 'J', 00H, 'P', 00H, 'G', 00H, 00H, 00H
	ORG $+2
$SG-339	DB	'd', 00H, 'v', 00H, 'h', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG-338	DB	'd', 00H, 'v', 00H, 's', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG-337	DB	'd', 00H, 'v', 00H, 's', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG-336	DB	'H', 00H, '2', 00H, '6', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG-335	DB	'M', 00H, 'P', 00H, 'E', 00H, 'G', 00H, '2', 00H, '_', 00H
	DB	'V', 00H, 'I', 00H, 'D', 00H, 'E', 00H, 'O', 00H, 00H, 00H
$SG-334	DB	'H', 00H, 'D', 00H, 'Y', 00H, 'C', 00H, 00H, 00H
	ORG $+2
$SG-333	DB	'U', 00H, 'Y', 00H, 'V', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG-332	DB	'Y', 00H, 'U', 00H, 'Y', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG-331	DB	'Y', 00H, 'V', 00H, 'Y', 00H, 'U', 00H, 00H, 00H
	ORG $+2
$SG-330	DB	'Y', 00H, 'V', 00H, 'U', 00H, '9', 00H, 00H, 00H
	ORG $+2
$SG-329	DB	'Y', 00H, '4', 00H, '1', 00H, 'P', 00H, 00H, 00H
	ORG $+2
$SG-328	DB	'Y', 00H, 'V', 00H, '1', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG-327	DB	'I', 00H, '4', 00H, '2', 00H, '0', 00H, 00H, 00H
	ORG $+2
$SG-326	DB	'R', 00H, 'G', 00H, 'B', 00H, 'A', 00H, '3', 00H, '2', 00H
	DB	00H, 00H
	ORG $+2
$SG-325	DB	'R', 00H, 'G', 00H, 'B', 00H, '3', 00H, '2', 00H, 00H, 00H
$SG-324	DB	'R', 00H, 'G', 00H, 'B', 00H, '2', 00H, '4', 00H, 00H, 00H
$SG-323	DB	'N', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG-341	DB	'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, 00H, 00H
$SG-342	DB	'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, 00H, 00H
$SG-343	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 'P', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG-344	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 00H, 00H
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@PAUSampleData@@@@QAEAAPAUSampleData@@I@Z
_TEXT	SEGMENT
??A?$List@PAUSampleData@@@@QAEAAPAUSampleData@@I@Z PROC	; List<SampleData *>::operator[], COMDAT
; _this$ = esi
; _index$ = eax

; 375  :         assert(index < num);
; 376  :         if(index >= num) {CrashError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	cmp	eax, DWORD PTR [esi+4]
	jb	SHORT $LN1@operator@2
	push	eax
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0PAUSampleData@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH

; 378  :     }

	ret	0
$LN1@operator@2:

; 377  :         return array[index];

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]

; 378  :     }

	ret	0
??A?$List@PAUSampleData@@@@QAEAAPAUSampleData@@I@Z ENDP	; List<SampleData *>::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Num@?$List@PAUSampleData@@@@QBEIXZ
_TEXT	SEGMENT
?Num@?$List@PAUSampleData@@@@QBEIXZ PROC		; List<SampleData *>::Num, COMDAT
; _this$ = eax

; 37   :     inline unsigned int Num() const     {return num;}

	mov	eax, DWORD PTR [eax+4]
	ret	0
?Num@?$List@PAUSampleData@@@@QBEIXZ ENDP		; List<SampleData *>::Num
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\capturefilter.cpp
_TEXT	ENDS
;	COMDAT ?Reset@CaptureEnumMediaTypes@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Reset@CaptureEnumMediaTypes@@UAGJXZ PROC		; CaptureEnumMediaTypes::Reset, COMDAT

; 417  : STDMETHODIMP CaptureEnumMediaTypes::Reset()                                                                 {return S_OK;}

	xor	eax, eax
	ret	4
?Reset@CaptureEnumMediaTypes@@UAGJXZ ENDP		; CaptureEnumMediaTypes::Reset
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Skip@CaptureEnumMediaTypes@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cMediaTypes$ = 12					; size = 4
?Skip@CaptureEnumMediaTypes@@UAGJK@Z PROC		; CaptureEnumMediaTypes::Skip, COMDAT

; 416  : STDMETHODIMP CaptureEnumMediaTypes::Skip(ULONG cMediaTypes)                                                 {return S_FALSE;}

	mov	eax, 1
	ret	8
?Skip@CaptureEnumMediaTypes@@UAGJK@Z ENDP		; CaptureEnumMediaTypes::Skip
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Next@CaptureEnumMediaTypes@@UAGJKPAPAU_AMMediaType@@PAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cMediaTypes$ = 12					; size = 4
_ppMediaTypes$ = 16					; size = 4
_pcFetched$ = 20					; size = 4
?Next@CaptureEnumMediaTypes@@UAGJKPAPAU_AMMediaType@@PAK@Z PROC ; CaptureEnumMediaTypes::Next, COMDAT

; 415  : STDMETHODIMP CaptureEnumMediaTypes::Next(ULONG cMediaTypes, AM_MEDIA_TYPE **ppMediaTypes, ULONG *pcFetched) {return S_FALSE;}

	mov	eax, 1
	ret	16					; 00000010H
?Next@CaptureEnumMediaTypes@@UAGJKPAPAU_AMMediaType@@PAK@Z ENDP ; CaptureEnumMediaTypes::Next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Release@CaptureEnumMediaTypes@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CaptureEnumMediaTypes@@UAGKXZ PROC		; CaptureEnumMediaTypes::Release, COMDAT

; 412  : STDMETHODIMP_(ULONG) CaptureEnumMediaTypes::Release() {if(!InterlockedDecrement(&refCount)) {delete this; return 0;} return refCount;}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi
	lea	edi, DWORD PTR [esi+4]
	push	edi
	call	DWORD PTR __imp__InterlockedDecrement@4
	test	eax, eax
	jne	SHORT $LN1@Release
	test	esi, esi
	je	SHORT $LN4@Release
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+28]
	push	1
	mov	ecx, esi
	call	edx
$LN4@Release:
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	4
$LN1@Release:
	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?Release@CaptureEnumMediaTypes@@UAGKXZ ENDP		; CaptureEnumMediaTypes::Release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?AddRef@CaptureEnumMediaTypes@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CaptureEnumMediaTypes@@UAGKXZ PROC		; CaptureEnumMediaTypes::AddRef, COMDAT

; 411  : STDMETHODIMP_(ULONG) CaptureEnumMediaTypes::AddRef()  {return ++refCount;}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	inc	eax
	mov	DWORD PTR [ecx+4], eax
	pop	ebp
	ret	4
?AddRef@CaptureEnumMediaTypes@@UAGKXZ ENDP		; CaptureEnumMediaTypes::AddRef
_TEXT	ENDS
PUBLIC	??1CaptureEnumMediaTypes@@UAE@XZ		; CaptureEnumMediaTypes::~CaptureEnumMediaTypes
; Function compile flags: /Ogtp
;	COMDAT ??1CaptureEnumMediaTypes@@UAE@XZ
_TEXT	SEGMENT
??1CaptureEnumMediaTypes@@UAE@XZ PROC			; CaptureEnumMediaTypes::~CaptureEnumMediaTypes, COMDAT
; _this$ = ecx

; 392  : {

	mov	DWORD PTR [ecx], OFFSET ??_7CaptureEnumMediaTypes@@6B@

; 393  :     pin->Release();

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx

; 394  : }

	ret	0
??1CaptureEnumMediaTypes@@UAE@XZ ENDP			; CaptureEnumMediaTypes::~CaptureEnumMediaTypes
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Reset@CaptureEnumPins@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Reset@CaptureEnumPins@@UAGJXZ PROC			; CaptureEnumPins::Reset, COMDAT

; 375  : STDMETHODIMP CaptureEnumPins::Reset()               {curPin = 0; return S_OK;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	xor	eax, eax
	pop	ebp
	ret	4
?Reset@CaptureEnumPins@@UAGJXZ ENDP			; CaptureEnumPins::Reset
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Skip@CaptureEnumPins@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cPins$ = 12						; size = 4
?Skip@CaptureEnumPins@@UAGJK@Z PROC			; CaptureEnumPins::Skip, COMDAT

; 374  : STDMETHODIMP CaptureEnumPins::Skip(ULONG cPins)     {return (++curPin > 1) ? S_FALSE : S_OK;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _this$[ebp]
	inc	DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, 1
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax
	pop	ebp
	ret	8
?Skip@CaptureEnumPins@@UAGJK@Z ENDP			; CaptureEnumPins::Skip
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Release@CaptureEnumPins@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CaptureEnumPins@@UAGKXZ PROC			; CaptureEnumPins::Release, COMDAT

; 353  : STDMETHODIMP_(ULONG) CaptureEnumPins::Release() {if(!InterlockedDecrement(&refCount)) {delete this; return 0;} return refCount;}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi
	lea	edi, DWORD PTR [esi+4]
	push	edi
	call	DWORD PTR __imp__InterlockedDecrement@4
	test	eax, eax
	jne	SHORT $LN1@Release@2
	test	esi, esi
	je	SHORT $LN4@Release@2
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+28]
	push	1
	mov	ecx, esi
	call	edx
$LN4@Release@2:
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	4
$LN1@Release@2:
	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?Release@CaptureEnumPins@@UAGKXZ ENDP			; CaptureEnumPins::Release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?AddRef@CaptureEnumPins@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CaptureEnumPins@@UAGKXZ PROC			; CaptureEnumPins::AddRef, COMDAT

; 352  : STDMETHODIMP_(ULONG) CaptureEnumPins::AddRef()  {return ++refCount;}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	inc	eax
	mov	DWORD PTR [ecx+4], eax
	pop	ebp
	ret	4
?AddRef@CaptureEnumPins@@UAGKXZ ENDP			; CaptureEnumPins::AddRef
_TEXT	ENDS
PUBLIC	??1CaptureEnumPins@@UAE@XZ			; CaptureEnumPins::~CaptureEnumPins
; Function compile flags: /Ogtp
;	COMDAT ??1CaptureEnumPins@@UAE@XZ
_TEXT	SEGMENT
??1CaptureEnumPins@@UAE@XZ PROC				; CaptureEnumPins::~CaptureEnumPins, COMDAT
; _this$ = ecx

; 332  : {

	mov	DWORD PTR [ecx], OFFSET ??_7CaptureEnumPins@@6B@

; 333  :     filter->Release();

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx

; 334  : }

	ret	0
??1CaptureEnumPins@@UAE@XZ ENDP				; CaptureEnumPins::~CaptureEnumPins
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?QueryVendorInfo@CaptureFilter@@UAGJPAPA_W@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVendorInfo$ = 12					; size = 4
?QueryVendorInfo@CaptureFilter@@UAGJPAPA_W@Z PROC	; CaptureFilter::QueryVendorInfo, COMDAT

; 319  : STDMETHODIMP CaptureFilter::QueryVendorInfo(LPWSTR *pVendorInfo)                   {return E_NOTIMPL;}

	mov	eax, -2147467263			; 80004001H
	ret	8
?QueryVendorInfo@CaptureFilter@@UAGJPAPA_W@Z ENDP	; CaptureFilter::QueryVendorInfo
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?JoinFilterGraph@CaptureFilter@@UAGJPAUIFilterGraph@@PB_W@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pGraph$ = 12						; size = 4
_pName$ = 16						; size = 4
?JoinFilterGraph@CaptureFilter@@UAGJPAUIFilterGraph@@PB_W@Z PROC ; CaptureFilter::JoinFilterGraph, COMDAT

; 318  : STDMETHODIMP CaptureFilter::JoinFilterGraph(IFilterGraph *pGraph, LPCWSTR pName)   {graph = pGraph; return NOERROR;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pGraph$[ebp]
	mov	DWORD PTR [eax+12], ecx
	xor	eax, eax
	pop	ebp
	ret	12					; 0000000cH
?JoinFilterGraph@CaptureFilter@@UAGJPAUIFilterGraph@@PB_W@Z ENDP ; CaptureFilter::JoinFilterGraph
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?QueryFilterInfo@CaptureFilter@@UAGJPAU_FilterInfo@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pInfo$ = 12						; size = 4
?QueryFilterInfo@CaptureFilter@@UAGJPAU_FilterInfo@@@Z PROC ; CaptureFilter::QueryFilterInfo, COMDAT

; 310  : {

	push	ebp
	mov	ebp, esp

; 311  :     mcpy(pInfo->achName, FILTER_NAME, sizeof(FILTER_NAME));

	mov	edx, DWORD PTR _pInfo$[ebp]

; 312  : 
; 313  :     pInfo->pGraph = graph;

	mov	eax, DWORD PTR _this$[ebp]
	push	esi
	push	edi
	mov	ecx, 7
	mov	esi, OFFSET $SG-344
	mov	edi, edx
	rep movsd
	movsw
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+256], ecx

; 314  :     if(graph) graph->AddRef();

	cmp	DWORD PTR [eax+12], 0
	pop	edi
	pop	esi
	je	SHORT $LN4@QueryFilte
	mov	eax, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN4@QueryFilte:

; 315  :     return NOERROR;

	xor	eax, eax

; 316  : }

	pop	ebp
	ret	8
?QueryFilterInfo@CaptureFilter@@UAGJPAU_FilterInfo@@@Z ENDP ; CaptureFilter::QueryFilterInfo
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?FindPin@CaptureFilter@@UAGJPB_WPAPAUIPin@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_Id$ = 12						; size = 4
_ppPin$ = 16						; size = 4
?FindPin@CaptureFilter@@UAGJPB_WPAPAUIPin@@@Z PROC	; CaptureFilter::FindPin, COMDAT

; 308  : STDMETHODIMP CaptureFilter::FindPin(LPCWSTR Id, IPin **ppPin) {return E_NOTIMPL;}

	mov	eax, -2147467263			; 80004001H
	ret	12					; 0000000cH
?FindPin@CaptureFilter@@UAGJPB_WPAPAUIPin@@@Z ENDP	; CaptureFilter::FindPin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Run@CaptureFilter@@UAGJ_J@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_tStart$ = 12						; size = 8
?Run@CaptureFilter@@UAGJ_J@Z PROC			; CaptureFilter::Run, COMDAT

; 299  : STDMETHODIMP CaptureFilter::Run(REFERENCE_TIME tStart)                     {state = State_Running; return S_OK;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 2
	xor	eax, eax
	pop	ebp
	ret	12					; 0000000cH
?Run@CaptureFilter@@UAGJ_J@Z ENDP			; CaptureFilter::Run
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Pause@CaptureFilter@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Pause@CaptureFilter@@UAGJXZ PROC			; CaptureFilter::Pause, COMDAT

; 298  : STDMETHODIMP CaptureFilter::Pause()                                        {state = State_Paused;  return S_OK;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
	xor	eax, eax
	pop	ebp
	ret	4
?Pause@CaptureFilter@@UAGJXZ ENDP			; CaptureFilter::Pause
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Stop@CaptureFilter@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Stop@CaptureFilter@@UAGJXZ PROC			; CaptureFilter::Stop, COMDAT

; 297  : STDMETHODIMP CaptureFilter::Stop()                                         {pin->EndFlush(); state = State_Stopped; return S_OK;}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+64]
	push	eax
	call	edx
	mov	DWORD PTR [esi+8], 0
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	4
?Stop@CaptureFilter@@UAGJXZ ENDP			; CaptureFilter::Stop
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetSyncSource@CaptureFilter@@UAGJPAPAUIReferenceClock@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pClock$ = 12						; size = 4
?GetSyncSource@CaptureFilter@@UAGJPAPAUIReferenceClock@@@Z PROC ; CaptureFilter::GetSyncSource, COMDAT

; 296  : STDMETHODIMP CaptureFilter::GetSyncSource(IReferenceClock **pClock)        {*pClock = NULL; return NOERROR;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pClock$[ebp]
	mov	DWORD PTR [eax], 0
	xor	eax, eax
	pop	ebp
	ret	8
?GetSyncSource@CaptureFilter@@UAGJPAPAUIReferenceClock@@@Z ENDP ; CaptureFilter::GetSyncSource
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?SetSyncSource@CaptureFilter@@UAGJPAUIReferenceClock@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pClock$ = 12						; size = 4
?SetSyncSource@CaptureFilter@@UAGJPAUIReferenceClock@@@Z PROC ; CaptureFilter::SetSyncSource, COMDAT

; 295  : STDMETHODIMP CaptureFilter::SetSyncSource(IReferenceClock *pClock)         {return S_OK;}

	xor	eax, eax
	ret	8
?SetSyncSource@CaptureFilter@@UAGJPAUIReferenceClock@@@Z ENDP ; CaptureFilter::SetSyncSource
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetState@CaptureFilter@@UAGJKPAW4_FilterState@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwMSecs$ = 12						; size = 4
_State$ = 16						; size = 4
?GetState@CaptureFilter@@UAGJKPAW4_FilterState@@@Z PROC	; CaptureFilter::GetState, COMDAT

; 294  : STDMETHODIMP CaptureFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)   {*State = state; return S_OK;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _State$[ebp]
	mov	DWORD PTR [edx], ecx
	xor	eax, eax
	pop	ebp
	ret	12					; 0000000cH
?GetState@CaptureFilter@@UAGJKPAW4_FilterState@@@Z ENDP	; CaptureFilter::GetState
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetClassID@CaptureFilter@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pClsID$ = 12						; size = 4
?GetClassID@CaptureFilter@@UAGJPAU_GUID@@@Z PROC	; CaptureFilter::GetClassID, COMDAT

; 291  : STDMETHODIMP CaptureFilter::GetClassID(CLSID *pClsID) {return E_NOTIMPL;}

	mov	eax, -2147467263			; 80004001H
	ret	8
?GetClassID@CaptureFilter@@UAGJPAU_GUID@@@Z ENDP	; CaptureFilter::GetClassID
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Release@CaptureFilter@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CaptureFilter@@UAGKXZ PROC			; CaptureFilter::Release, COMDAT

; 288  : STDMETHODIMP_(ULONG) CaptureFilter::Release() {if(!InterlockedDecrement(&refCount)) {delete this; return 0;} return refCount;}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi
	lea	edi, DWORD PTR [esi+4]
	push	edi
	call	DWORD PTR __imp__InterlockedDecrement@4
	test	eax, eax
	jne	SHORT $LN1@Release@3
	test	esi, esi
	je	SHORT $LN4@Release@3
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+60]
	push	1
	mov	ecx, esi
	call	edx
$LN4@Release@3:
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	4
$LN1@Release@3:
	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?Release@CaptureFilter@@UAGKXZ ENDP			; CaptureFilter::Release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?AddRef@CaptureFilter@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CaptureFilter@@UAGKXZ PROC			; CaptureFilter::AddRef, COMDAT

; 287  : STDMETHODIMP_(ULONG) CaptureFilter::AddRef()  {return ++refCount;}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	inc	eax
	mov	DWORD PTR [ecx+4], eax
	pop	ebp
	ret	4
?AddRef@CaptureFilter@@UAGKXZ ENDP			; CaptureFilter::AddRef
_TEXT	ENDS
PUBLIC	??1CaptureFilter@@UAE@XZ			; CaptureFilter::~CaptureFilter
; Function compile flags: /Ogtp
;	COMDAT ??1CaptureFilter@@UAE@XZ
_TEXT	SEGMENT
??1CaptureFilter@@UAE@XZ PROC				; CaptureFilter::~CaptureFilter, COMDAT
; _this$ = ecx

; 249  : {

	mov	DWORD PTR [ecx], OFFSET ??_7CaptureFilter@@6B@

; 250  :     pin->Release();

	mov	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx

; 251  : }

	ret	0
??1CaptureFilter@@UAE@XZ ENDP				; CaptureFilter::~CaptureFilter
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ReceiveCanBlock@CapturePin@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?ReceiveCanBlock@CapturePin@@UAGJXZ PROC		; CapturePin::ReceiveCanBlock, COMDAT

; 216  : STDMETHODIMP CapturePin::ReceiveCanBlock() {return S_FALSE;}

	mov	eax, 1
	ret	4
?ReceiveCanBlock@CapturePin@@UAGJXZ ENDP		; CapturePin::ReceiveCanBlock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ReceiveMultiple@CapturePin@@UAGJPAPAUIMediaSample@@JPAJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pSamples$ = 12						; size = 4
_nSamples$ = 16						; size = 4
_nSamplesProcessed$ = 20				; size = 4
?ReceiveMultiple@CapturePin@@UAGJPAPAUIMediaSample@@JPAJ@Z PROC ; CapturePin::ReceiveMultiple, COMDAT

; 209  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 210  :     for(long i=0; i<nSamples; i++)

	mov	ebx, DWORD PTR _nSamples$[ebp]
	push	esi
	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN8@ReceiveMul
	push	edi
	mov	edi, DWORD PTR _this$[ebp]
$LL3@ReceiveMul:

; 211  :         Receive(pSamples[i]);

	mov	ecx, DWORD PTR _pSamples$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+24]
	push	edx
	push	edi
	call	eax
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL3@ReceiveMul

; 212  :     *nSamplesProcessed = nSamples;

	mov	ecx, DWORD PTR _nSamplesProcessed$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], ebx

; 213  :     return S_OK;

	xor	eax, eax
	pop	ebx

; 214  : }

	pop	ebp
	ret	16					; 00000010H
$LN8@ReceiveMul:

; 212  :     *nSamplesProcessed = nSamples;

	mov	edx, DWORD PTR _nSamplesProcessed$[ebp]
	pop	esi
	mov	DWORD PTR [edx], ebx

; 213  :     return S_OK;

	xor	eax, eax
	pop	ebx

; 214  : }

	pop	ebp
	ret	16					; 00000010H
?ReceiveMultiple@CapturePin@@UAGJPAPAUIMediaSample@@JPAJ@Z ENDP ; CapturePin::ReceiveMultiple
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetAllocatorRequirements@CapturePin@@UAGJPAU_AllocatorProperties@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pProps$ = 12						; size = 4
?GetAllocatorRequirements@CapturePin@@UAGJPAU_AllocatorProperties@@@Z PROC ; CapturePin::GetAllocatorRequirements, COMDAT

; 194  : STDMETHODIMP CapturePin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)        {return E_NOTIMPL;}

	mov	eax, -2147467263			; 80004001H
	ret	8
?GetAllocatorRequirements@CapturePin@@UAGJPAU_AllocatorProperties@@@Z ENDP ; CapturePin::GetAllocatorRequirements
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?NotifyAllocator@CapturePin@@UAGJPAUIMemAllocator@@H@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pAllocator$ = 12					; size = 4
_bReadOnly$ = 16					; size = 4
?NotifyAllocator@CapturePin@@UAGJPAUIMemAllocator@@H@Z PROC ; CapturePin::NotifyAllocator, COMDAT

; 193  : STDMETHODIMP CapturePin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)    {return S_OK;}

	xor	eax, eax
	ret	12					; 0000000cH
?NotifyAllocator@CapturePin@@UAGJPAUIMemAllocator@@H@Z ENDP ; CapturePin::NotifyAllocator
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?GetAllocator@CapturePin@@UAGJPAPAUIMemAllocator@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppAllocator$ = 12					; size = 4
?GetAllocator@CapturePin@@UAGJPAPAUIMemAllocator@@@Z PROC ; CapturePin::GetAllocator, COMDAT

; 192  : STDMETHODIMP CapturePin::GetAllocator(IMemAllocator **ppAllocator)                     {return VFW_E_NO_ALLOCATOR;}

	mov	eax, -2147220982			; 8004020aH
	ret	8
?GetAllocator@CapturePin@@UAGJPAPAUIMemAllocator@@@Z ENDP ; CapturePin::GetAllocator
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?NewSegment@CapturePin@@UAGJ_J0N@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_tStart$ = 12						; size = 8
_tStop$ = 20						; size = 8
_dRate$ = 28						; size = 8
?NewSegment@CapturePin@@UAGJ_J0N@Z PROC			; CapturePin::NewSegment, COMDAT

; 189  : STDMETHODIMP CapturePin::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate) {return S_OK;}

	xor	eax, eax
	ret	28					; 0000001cH
?NewSegment@CapturePin@@UAGJ_J0N@Z ENDP			; CapturePin::NewSegment
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?BeginFlush@CapturePin@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?BeginFlush@CapturePin@@UAGJXZ PROC			; CapturePin::BeginFlush, COMDAT

; 182  : STDMETHODIMP CapturePin::BeginFlush()                                          {return S_OK;}

	xor	eax, eax
	ret	4
?BeginFlush@CapturePin@@UAGJXZ ENDP			; CapturePin::BeginFlush
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?EndOfStream@CapturePin@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?EndOfStream@CapturePin@@UAGJXZ PROC			; CapturePin::EndOfStream, COMDAT

; 181  : STDMETHODIMP CapturePin::EndOfStream()                                         {return S_OK;}

	xor	eax, eax
	ret	4
?EndOfStream@CapturePin@@UAGJXZ ENDP			; CapturePin::EndOfStream
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?QueryInternalConnections@CapturePin@@UAGJPAPAUIPin@@PAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_apPin$ = 12						; size = 4
_nPin$ = 16						; size = 4
?QueryInternalConnections@CapturePin@@UAGJPAPAUIPin@@PAK@Z PROC ; CapturePin::QueryInternalConnections, COMDAT

; 180  : STDMETHODIMP CapturePin::QueryInternalConnections(IPin **apPin, ULONG *nPin)   {return E_NOTIMPL;}

	mov	eax, -2147467263			; 80004001H
	ret	12					; 0000000cH
?QueryInternalConnections@CapturePin@@UAGJPAPAUIPin@@PAK@Z ENDP ; CapturePin::QueryInternalConnections
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?QueryId@CapturePin@@UAGJPAPA_W@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_lpId$ = 12						; size = 4
?QueryId@CapturePin@@UAGJPAPA_W@Z PROC			; CapturePin::QueryId, COMDAT

; 152  : STDMETHODIMP CapturePin::QueryId(LPWSTR *lpId)                     {*lpId = L"Capture Pin"; return S_OK;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lpId$[ebp]
	mov	DWORD PTR [eax], OFFSET $SG-343
	xor	eax, eax
	pop	ebp
	ret	8
?QueryId@CapturePin@@UAGJPAPA_W@Z ENDP			; CapturePin::QueryId
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?QueryDirection@CapturePin@@UAGJPAW4_PinDirection@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pPinDir$ = 12						; size = 4
?QueryDirection@CapturePin@@UAGJPAW4_PinDirection@@@Z PROC ; CapturePin::QueryDirection, COMDAT

; 151  : STDMETHODIMP CapturePin::QueryDirection(PIN_DIRECTION *pPinDir)    {*pPinDir = PINDIR_INPUT; return NOERROR;}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pPinDir$[ebp]
	mov	DWORD PTR [eax], 0
	xor	eax, eax
	pop	ebp
	ret	8
?QueryDirection@CapturePin@@UAGJPAW4_PinDirection@@@Z ENDP ; CapturePin::QueryDirection
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ConnectionMediaType@CapturePin@@UAGJPAU_AMMediaType@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pmt$ = 12						; size = 4
?ConnectionMediaType@CapturePin@@UAGJPAU_AMMediaType@@@Z PROC ; CapturePin::ConnectionMediaType, COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :     if(!connectedPin)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	jne	SHORT $LN1@Connection

; 131  :         return VFW_E_NOT_CONNECTED;

	mov	eax, -2147220983			; 80040209H

; 134  : }

	pop	ebp
	ret	8
$LN1@Connection:

; 132  : 
; 133  :     return CopyMediaType(pmt, &connectedMediaType);

	add	eax, 52					; 00000034H
	push	eax
	mov	eax, DWORD PTR _pmt$[ebp]
	call	?CopyMediaType@@YGJPAU_AMMediaType@@PBU1@@Z ; CopyMediaType

; 134  : }

	pop	ebp
	ret	8
?ConnectionMediaType@CapturePin@@UAGJPAU_AMMediaType@@@Z ENDP ; CapturePin::ConnectionMediaType
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ConnectedTo@CapturePin@@UAGJPAPAUIPin@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pPin$ = 12						; size = 4
?ConnectedTo@CapturePin@@UAGJPAPAUIPin@@@Z PROC		; CapturePin::ConnectedTo, COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 120  :     if(!connectedPin)

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+124], 0
	jne	SHORT $LN1@ConnectedT

; 121  :         return VFW_E_NOT_CONNECTED;

	mov	eax, -2147220983			; 80040209H
	pop	esi

; 126  : }

	pop	ebp
	ret	8
$LN1@ConnectedT:

; 122  : 
; 123  :     connectedPin->AddRef();

	mov	eax, DWORD PTR [esi+124]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx

; 124  :     *pPin = connectedPin;

	mov	eax, DWORD PTR [esi+124]
	mov	ecx, DWORD PTR _pPin$[ebp]
	mov	DWORD PTR [ecx], eax

; 125  :     return S_OK;

	xor	eax, eax
	pop	esi

; 126  : }

	pop	ebp
	ret	8
?ConnectedTo@CapturePin@@UAGJPAPAUIPin@@@Z ENDP		; CapturePin::ConnectedTo
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Disconnect@CapturePin@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Disconnect@CapturePin@@UAGJXZ PROC			; CapturePin::Disconnect, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 109  :     if(!connectedPin)

	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+124]
	test	eax, eax
	jne	SHORT $LN1@Disconnect

; 110  :         return S_FALSE;

	mov	eax, 1
	pop	esi

; 115  : }

	pop	ebp
	ret	4
$LN1@Disconnect:

; 111  : 
; 112  :     connectedPin->Release();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx

; 113  :     connectedPin = NULL;

	mov	DWORD PTR [esi+124], 0

; 114  :     return S_OK;

	xor	eax, eax
	pop	esi

; 115  : }

	pop	ebp
	ret	4
?Disconnect@CapturePin@@UAGJXZ ENDP			; CapturePin::Disconnect
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?ReceiveConnection@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pConnector$ = 12					; size = 4
_pmt$ = 16						; size = 4
?ReceiveConnection@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z PROC ; CapturePin::ReceiveConnection, COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 90   :     if(filter->state != State_Stopped)

	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+48]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@ReceiveCon

; 91   :         return VFW_E_NOT_STOPPED;

	mov	eax, -2147220956			; 80040224H
	pop	esi

; 105  : }

	pop	ebp
	ret	12					; 0000000cH
$LN5@ReceiveCon:
	push	ebx
	push	edi

; 92   :     if(!pConnector || !pmt)

	mov	edi, DWORD PTR _pConnector$[ebp]
	test	edi, edi
	je	SHORT $LN3@ReceiveCon
	mov	ebx, DWORD PTR _pmt$[ebp]
	test	ebx, ebx
	je	SHORT $LN3@ReceiveCon

; 94   :     if(connectedPin)

	cmp	DWORD PTR [esi+124], 0
	je	SHORT $LN2@ReceiveCon

; 95   :         return VFW_E_ALREADY_CONNECTED;

	pop	edi
	pop	ebx
	mov	eax, -2147220988			; 80040204H
	pop	esi

; 105  : }

	pop	ebp
	ret	12					; 0000000cH
$LN2@ReceiveCon:

; 96   : 
; 97   :     if(QueryAccept(pmt) != S_OK)

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+44]
	push	ebx
	push	esi
	call	edx
	test	eax, eax
	je	SHORT $LN1@ReceiveCon

; 98   :         return VFW_E_TYPE_NOT_ACCEPTED;

	pop	edi
	pop	ebx
	mov	eax, -2147220950			; 8004022aH
	pop	esi

; 105  : }

	pop	ebp
	ret	12					; 0000000cH
$LN1@ReceiveCon:

; 99   : 
; 100  :     connectedPin = pConnector;

	mov	DWORD PTR [esi+124], edi

; 101  :     connectedPin->AddRef();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	call	ecx

; 102  : 
; 103  :     FreeMediaType(connectedMediaType);

	add	esi, 52					; 00000034H
	call	?FreeMediaType@@YGXAAU_AMMediaType@@@Z	; FreeMediaType

; 104  :     return CopyMediaType(&connectedMediaType, pmt);

	push	ebx
	mov	eax, esi
	call	?CopyMediaType@@YGJPAU_AMMediaType@@PBU1@@Z ; CopyMediaType
	pop	edi
	pop	ebx
	pop	esi

; 105  : }

	pop	ebp
	ret	12					; 0000000cH
$LN3@ReceiveCon:
	pop	edi
	pop	ebx

; 93   :         return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	pop	esi

; 105  : }

	pop	ebp
	ret	12					; 0000000cH
?ReceiveConnection@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z ENDP ; CapturePin::ReceiveConnection
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Release@CapturePin@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CapturePin@@UAGKXZ PROC			; CapturePin::Release, COMDAT

; 69   : STDMETHODIMP_(ULONG) CapturePin::Release() {if(!InterlockedDecrement(&refCount)) {delete this; return 0;} return refCount;}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi
	lea	edi, DWORD PTR [esi+8]
	push	edi
	call	DWORD PTR __imp__InterlockedDecrement@4
	test	eax, eax
	jne	SHORT $LN1@Release@4
	test	esi, esi
	je	SHORT $LN4@Release@4
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+72]
	push	1
	mov	ecx, esi
	call	edx
$LN4@Release@4:
	pop	edi
	xor	eax, eax
	pop	esi
	pop	ebp
	ret	4
$LN1@Release@4:
	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?Release@CapturePin@@UAGKXZ ENDP			; CapturePin::Release
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?AddRef@CapturePin@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CapturePin@@UAGKXZ PROC				; CapturePin::AddRef, COMDAT

; 68   : STDMETHODIMP_(ULONG) CapturePin::AddRef()  {return ++refCount;}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	inc	eax
	mov	DWORD PTR [ecx+8], eax
	pop	ebp
	ret	4
?AddRef@CapturePin@@UAGKXZ ENDP				; CapturePin::AddRef
_TEXT	ENDS
PUBLIC	??1CapturePin@@UAE@XZ				; CapturePin::~CapturePin
; Function compile flags: /Ogtp
;	COMDAT ??1CapturePin@@UAE@XZ
_TEXT	SEGMENT
??1CapturePin@@UAE@XZ PROC				; CapturePin::~CapturePin, COMDAT
; _this$ = ecx

; 43   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CapturePin@@6BIPin@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7CapturePin@@6BIMemInputPin@@@

; 44   :     FreeMediaType(connectedMediaType);

	cmp	DWORD PTR [esi+116], 0
	je	SHORT $LN4@CapturePin
	mov	eax, DWORD PTR [esi+120]
	push	eax
	call	DWORD PTR __imp__CoTaskMemFree@4
	mov	DWORD PTR [esi+116], 0
	mov	DWORD PTR [esi+120], 0
$LN4@CapturePin:
	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN3@CapturePin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+112], 0
$LN3@CapturePin:
	pop	esi

; 45   : }

	ret	0
??1CapturePin@@UAE@XZ ENDP				; CapturePin::~CapturePin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
??0IUnknown@@QAE@XZ PROC				; IUnknown::IUnknown, COMDAT
; _this$ = eax
	ret	0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IMemInputPin@@QAE@XZ
_TEXT	SEGMENT
??0IMemInputPin@@QAE@XZ PROC				; IMemInputPin::IMemInputPin, COMDAT
; _this$ = eax
	ret	0
??0IMemInputPin@@QAE@XZ ENDP				; IMemInputPin::IMemInputPin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IPin@@QAE@XZ
_TEXT	SEGMENT
??0IPin@@QAE@XZ PROC					; IPin::IPin, COMDAT
; _this$ = eax
	ret	0
??0IPin@@QAE@XZ ENDP					; IPin::IPin
_TEXT	ENDS
PUBLIC	??0CapturePin@@QAE@PAVCaptureFilter@@PAVDeviceSource@@ABU_GUID@@2@Z ; CapturePin::CapturePin
; Function compile flags: /Ogtp
;	COMDAT ??0CapturePin@@QAE@PAVCaptureFilter@@PAVDeviceSource@@ABU_GUID@@2@Z
_TEXT	SEGMENT
_filterIn$ = 8						; size = 4
_sourceIn$ = 12						; size = 4
??0CapturePin@@QAE@PAVCaptureFilter@@PAVDeviceSource@@ABU_GUID@@2@Z PROC ; CapturePin::CapturePin, COMDAT
; _this$ = eax
; _expectedMajorType$ = ecx
; _expectedMediaType$ = edx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _sourceIn$[ebp]
	mov	DWORD PTR [eax+44], esi
	mov	esi, DWORD PTR _filterIn$[ebp]
	mov	DWORD PTR [eax+48], esi
	mov	DWORD PTR [eax], OFFSET ??_7CapturePin@@6BIPin@@@
	mov	DWORD PTR [eax+4], OFFSET ??_7CapturePin@@6BIMemInputPin@@@
	mov	DWORD PTR [eax+8], 1

; 33   :     connectedMediaType.majortype = expectedMajorType;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+52], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+56], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+60], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+64], esi

; 34   :     connectedMediaType.subtype   = GUID_NULL;

	mov	esi, DWORD PTR _GUID_NULL
	mov	DWORD PTR [eax+68], esi
	mov	esi, DWORD PTR _GUID_NULL+4
	mov	DWORD PTR [eax+72], esi
	mov	esi, DWORD PTR _GUID_NULL+8
	mov	DWORD PTR [eax+76], esi
	mov	esi, DWORD PTR _GUID_NULL+12
	mov	DWORD PTR [eax+80], esi

; 35   :     connectedMediaType.pbFormat  = NULL;

	xor	esi, esi
	mov	DWORD PTR [eax+120], esi

; 36   :     connectedMediaType.cbFormat  = 0;

	mov	DWORD PTR [eax+116], esi

; 37   :     connectedMediaType.pUnk      = NULL;

	mov	DWORD PTR [eax+112], esi

; 38   :     this->expectedMediaType = expectedMediaType;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax+28], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+32], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+36], esi
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+40], edx

; 39   :     this->expectedMajorType = expectedMajorType;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+20], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], ecx
	pop	esi

; 40   : }

	pop	ebp
	ret	8
??0CapturePin@@QAE@PAVCaptureFilter@@PAVDeviceSource@@ABU_GUID@@2@Z ENDP ; CapturePin::CapturePin
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\capturefilter.h
_TEXT	ENDS
;	COMDAT ?GetCapturePin@CaptureFilter@@QBEPAVCapturePin@@XZ
_TEXT	SEGMENT
?GetCapturePin@CaptureFilter@@QBEPAVCapturePin@@XZ PROC	; CaptureFilter::GetCapturePin, COMDAT
; _this$ = eax

; 119  :     inline CapturePin* GetCapturePin() const {return pin;}

	mov	eax, DWORD PTR [eax+16]
	ret	0
?GetCapturePin@CaptureFilter@@QBEPAVCapturePin@@XZ ENDP	; CaptureFilter::GetCapturePin
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\alloc.h
_TEXT	ENDS
;	COMDAT ?Free@@YAXPAX@Z
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
?Free@@YAXPAX@Z PROC					; Free, COMDAT

; 66   : inline void Free(void *lpData)   {MainAllocator->_Free(lpData);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpData$[ebp]
	mov	edx, DWORD PTR [edx+12]
	push	eax
	call	edx
	pop	ebp
	ret	0
?Free@@YAXPAX@Z ENDP					; Free
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\inline.h
;	COMDAT ?zero@@YGXPAXI@Z
_TEXT	SEGMENT
?zero@@YGXPAXI@Z PROC					; zero, COMDAT
; _pDest$ = ecx
; _iLen$ = eax

; 200  : {

	push	ebx

; 201  :     assert(pDest);
; 202  : 
; 203  :     register size_t iLenMod4 = iLen&3;

	mov	edx, eax

; 204  :     register size_t iLenDiv4 = iLen>>2;

	shr	eax, 2
	push	esi
	mov	esi, eax
	and	edx, 3
	mov	ebx, ecx

; 205  : 
; 206  :     register DWORD *destDW = (DWORD*)pDest;
; 207  :     while(iLenDiv4--)

	test	esi, esi
	je	SHORT $LN4@zero

; 201  :     assert(pDest);
; 202  : 
; 203  :     register size_t iLenMod4 = iLen&3;

	push	edi
	mov	edi, ebx
	mov	ecx, esi
	xor	eax, eax
	rep stosd

; 205  : 
; 206  :     register DWORD *destDW = (DWORD*)pDest;
; 207  :     while(iLenDiv4--)

	lea	ebx, DWORD PTR [ebx+esi*4]
	pop	edi
$LN4@zero:

; 211  :     while(iLenMod4--)

	test	edx, edx
	je	SHORT $LN2@zero

; 208  :         *(destDW++) = 0;
; 209  : 
; 210  :     register BYTE *destB = (BYTE*)destDW;

	push	edx
	push	0
	push	ebx
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@zero:

; 212  :         *(destB++) = 0;
; 213  : }

	pop	esi
	pop	ebx
	ret	0
?zero@@YGXPAXI@Z ENDP					; zero
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.0\include\shared\guiddef.h
_TEXT	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_IsEqualGUID PROC					; COMDAT
; _rguid1$ = edx
; _rguid2$ = ecx

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	eax, 16					; 00000010H
	push	esi
$LL4@IsEqualGUI:
	mov	esi, DWORD PTR [edx]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN5@IsEqualGUI
	sub	eax, 4
	add	ecx, 4
	add	edx, 4
	cmp	eax, 4
	jae	SHORT $LL4@IsEqualGUI
	xor	eax, eax
	xor	edx, edx
	test	eax, eax
	sete	dl
	pop	esi
	mov	eax, edx

; 162  : }

	ret	0
$LN5@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	movzx	eax, BYTE PTR [edx]
	movzx	esi, BYTE PTR [ecx]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+1]
	movzx	esi, BYTE PTR [ecx+1]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+2]
	movzx	esi, BYTE PTR [ecx+2]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+3]
	movzx	ecx, BYTE PTR [ecx+3]
	sub	eax, ecx
$LN7@IsEqualGUI:
	sar	eax, 31					; 0000001fH
	or	eax, 1
	xor	edx, edx
	test	eax, eax
	sete	dl
	pop	esi
	mov	eax, edx

; 162  : }

	ret	0
_IsEqualGUID ENDP
; Function compile flags: /Odtp
;	COMDAT ?Release@CapturePin@@W3AGKXZ
_TEXT	SEGMENT
?Release@CapturePin@@W3AGKXZ PROC			; [thunk]:CapturePin::Release`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?Release@CapturePin@@UAGKXZ		; CapturePin::Release
?Release@CapturePin@@W3AGKXZ ENDP			; [thunk]:CapturePin::Release`adjustor{4}'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AddRef@CapturePin@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CapturePin@@W3AGKXZ PROC			; [thunk]:CapturePin::AddRef`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?AddRef@CapturePin@@UAGKXZ		; CapturePin::AddRef
?AddRef@CapturePin@@W3AGKXZ ENDP			; [thunk]:CapturePin::AddRef`adjustor{4}'
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\template.h
_TEXT	ENDS
;	COMDAT ?Clear@?$List@PAUSampleData@@@@QAEXXZ
_TEXT	SEGMENT
?Clear@?$List@PAUSampleData@@@@QAEXXZ PROC		; List<SampleData *>::Clear, COMDAT
; _this$ = esi

; 330  :         if(array)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN1@Clear@5

; 331  :         {
; 332  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 333  :                 CrashError(TEXT("what the.."));*/
; 334  :             Free(array);

	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 335  :             array = NULL;

	mov	DWORD PTR [esi], 0

; 336  :             num = 0;

	mov	DWORD PTR [esi+4], 0
$LN1@Clear@5:

; 337  :         }
; 338  :     }

	ret	0
?Clear@?$List@PAUSampleData@@@@QAEXXZ ENDP		; List<SampleData *>::Clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IEnumMediaTypes@@QAE@XZ
_TEXT	SEGMENT
??0IEnumMediaTypes@@QAE@XZ PROC				; IEnumMediaTypes::IEnumMediaTypes, COMDAT
; _this$ = eax
	ret	0
??0IEnumMediaTypes@@QAE@XZ ENDP				; IEnumMediaTypes::IEnumMediaTypes
_TEXT	ENDS
PUBLIC	??0CaptureEnumMediaTypes@@QAE@PAVCapturePin@@PAV0@@Z ; CaptureEnumMediaTypes::CaptureEnumMediaTypes
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\capturefilter.cpp
;	COMDAT ??0CaptureEnumMediaTypes@@QAE@PAVCapturePin@@PAV0@@Z
_TEXT	SEGMENT
??0CaptureEnumMediaTypes@@QAE@PAVCapturePin@@PAV0@@Z PROC ; CaptureEnumMediaTypes::CaptureEnumMediaTypes, COMDAT
; _this$ = esi
; _pinIn$ = eax

; 387  : {

	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumMediaTypes@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+8], eax

; 388  :     pin->AddRef();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx

; 389  : }

	mov	eax, esi
	ret	0
??0CaptureEnumMediaTypes@@QAE@PAVCapturePin@@PAV0@@Z ENDP ; CaptureEnumMediaTypes::CaptureEnumMediaTypes
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Next@CaptureEnumPins@@UAGJKPAPAUIPin@@PAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_cPins$ = 12						; size = 4
_ppPins$ = 16						; size = 4
_pcFetched$ = 20					; size = 4
?Next@CaptureEnumPins@@UAGJKPAPAUIPin@@PAK@Z PROC	; CaptureEnumPins::Next, COMDAT

; 357  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 358  :     UINT nFetched = 0;
; 359  : 
; 360  :     if(curPin == 0 && cPins > 0)

	mov	esi, DWORD PTR _this$[ebp]
	xor	eax, eax
	push	edi
	mov	edi, DWORD PTR _cPins$[ebp]
	cmp	DWORD PTR [esi+12], eax
	jne	SHORT $LN2@Next
	test	edi, edi
	je	SHORT $LN2@Next

; 361  :     {
; 362  :         IPin *pPin = filter->GetCapturePin();

	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+16]

; 363  :         *ppPins = pPin;

	mov	ecx, DWORD PTR _ppPins$[ebp]
	mov	DWORD PTR [ecx], eax

; 364  :         pPin->AddRef();

	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 365  :         nFetched = 1;

	mov	eax, 1

; 366  :         curPin++;

	add	DWORD PTR [esi+12], eax
$LN2@Next:

; 367  :     }
; 368  : 
; 369  :     if(pcFetched) *pcFetched = nFetched;

	mov	ecx, DWORD PTR _pcFetched$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@Next
	mov	DWORD PTR [ecx], eax
$LN1@Next:

; 370  : 
; 371  :     return (nFetched == cPins) ? S_OK : S_FALSE;

	xor	ecx, ecx
	cmp	eax, edi
	setne	cl
	pop	edi
	pop	esi
	mov	eax, ecx

; 372  : }

	pop	ebp
	ret	16					; 00000010H
?Next@CaptureEnumPins@@UAGJKPAPAUIPin@@PAK@Z ENDP	; CaptureEnumPins::Next
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IEnumPins@@QAE@XZ
_TEXT	SEGMENT
??0IEnumPins@@QAE@XZ PROC				; IEnumPins::IEnumPins, COMDAT
; _this$ = eax
	ret	0
??0IEnumPins@@QAE@XZ ENDP				; IEnumPins::IEnumPins
_TEXT	ENDS
PUBLIC	??0CaptureEnumPins@@QAE@PAVCaptureFilter@@PAV0@@Z ; CaptureEnumPins::CaptureEnumPins
; Function compile flags: /Ogtp
;	COMDAT ??0CaptureEnumPins@@QAE@PAVCaptureFilter@@PAV0@@Z
_TEXT	SEGMENT
??0CaptureEnumPins@@QAE@PAVCaptureFilter@@PAV0@@Z PROC	; CaptureEnumPins::CaptureEnumPins, COMDAT
; _this$ = esi
; _filterIn$ = eax
; _pEnum$ = ecx

; 326  : {

	push	edi
	mov	edi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumPins@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+8], eax

; 327  :     filter->AddRef();

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx

; 328  :     curPin = (pEnum != NULL) ? pEnum->curPin : 0;

	test	edi, edi
	je	SHORT $LN3@CaptureEnu
	mov	edi, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], edi

; 329  : }

	mov	eax, esi
	pop	edi
	ret	0
$LN3@CaptureEnu:

; 328  :     curPin = (pEnum != NULL) ? pEnum->curPin : 0;

	xor	eax, eax
	mov	DWORD PTR [esi+12], eax

; 329  : }

	mov	eax, esi
	pop	edi
	ret	0
??0CaptureEnumPins@@QAE@PAVCaptureFilter@@PAV0@@Z ENDP	; CaptureEnumPins::CaptureEnumPins
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IPersist@@QAE@XZ
_TEXT	SEGMENT
??0IPersist@@QAE@XZ PROC				; IPersist::IPersist, COMDAT
; _this$ = eax
	ret	0
??0IPersist@@QAE@XZ ENDP				; IPersist::IPersist
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IMediaFilter@@QAE@XZ
_TEXT	SEGMENT
??0IMediaFilter@@QAE@XZ PROC				; IMediaFilter::IMediaFilter, COMDAT
; _this$ = eax
	ret	0
??0IMediaFilter@@QAE@XZ ENDP				; IMediaFilter::IMediaFilter
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0IBaseFilter@@QAE@XZ
_TEXT	SEGMENT
??0IBaseFilter@@QAE@XZ PROC				; IBaseFilter::IBaseFilter, COMDAT
; _this$ = eax
	ret	0
??0IBaseFilter@@QAE@XZ ENDP				; IBaseFilter::IBaseFilter
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.h
_TEXT	ENDS
;	COMDAT ??1SampleData@@QAE@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??1SampleData@@QAE@XZ PROC				; SampleData::~SampleData, COMDAT

; 49   :     inline ~SampleData() {Free(lpData);} //sample->Release();}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+12]
	push	eax
	call	edx
	pop	ebp
	ret	4
??1SampleData@@QAE@XZ ENDP				; SampleData::~SampleData
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\alloc.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_lpData$ = 8						; size = 4
??3@YAXPAX@Z PROC					; operator delete, COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp

; 97   :     Free(lpData);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpData$[ebp]
	mov	edx, DWORD PTR [edx+12]
	push	eax
	call	edx

; 98   : }

	pop	ebp
	ret	0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??2@YAPAXI@Z					; operator new
; Function compile flags: /Ogtp
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
??2@YAPAXI@Z PROC					; operator new, COMDAT
; _dwSize$ = eax

; 88   : {

	push	ebx
	push	esi
	mov	esi, eax

; 89   :     void* val = Allocate(dwSize);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	esi
	call	eax

; 90   :     zero(val, dwSize);

	mov	edx, esi
	shr	esi, 2
	and	edx, 3
	mov	ebx, eax
	test	esi, esi
	je	SHORT $LN6@operator@3

; 89   :     void* val = Allocate(dwSize);

	push	edi
	xor	eax, eax
	mov	ecx, esi
	mov	edi, ebx
	rep stosd

; 90   :     zero(val, dwSize);

	lea	eax, DWORD PTR [ebx+esi*4]
	pop	edi
$LN6@operator@3:
	test	edx, edx
	je	SHORT $LN15@operator@3
	push	edx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN15@operator@3:

; 91   : 
; 92   :     return val;

	pop	esi
	mov	eax, ebx
	pop	ebx

; 93   : }

	ret	0
??2@YAPAXI@Z ENDP					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.0\include\shared\guiddef.h
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT
_==	PROC						; COMDAT
; _guidOne$ = edx
; _guidOther$ = ecx

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

	call	_IsEqualGUID
	neg	eax
	sbb	eax, eax
	neg	eax

; 195  : }

	ret	0
_==	ENDP
;	COMDAT xdata$x
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\capturefilter.cpp
xdata$x	SEGMENT
__unwindtable$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z$0
__ehfuncinfo$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z
_TEXT	SEGMENT
$T106178 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z PROC ; CaptureEnumMediaTypes::Clone, COMDAT

; 419  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 420  :     *ppEnum = new CaptureEnumMediaTypes(pin, this);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	12					; 0000000cH
	call	eax
	mov	esi, eax
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR $T106178[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	cmp	esi, eax
	je	SHORT $LN3@Clone
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumMediaTypes@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	edx, DWORD PTR [eax]
	push	eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	eax, esi
$LN3@Clone:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppEnum$[ebp]
	mov	DWORD PTR [ecx], eax

; 421  :     return (*ppEnum == NULL) ? E_OUTOFMEMORY : NOERROR;

	neg	eax
	sbb	eax, eax
	and	eax, 2147024882				; 7ff8fff2H
	add	eax, -2147024882			; 8007000eH

; 422  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z$0:
	mov	eax, DWORD PTR $T106178[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Clone@CaptureEnumMediaTypes@@UAGJPAPAUIEnumMediaTypes@@@Z ENDP ; CaptureEnumMediaTypes::Clone
; Function compile flags: /Ogtp
;	COMDAT ?QueryInterface@CaptureEnumMediaTypes@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?QueryInterface@CaptureEnumMediaTypes@@UAGJABU_GUID@@PAPAX@Z PROC ; CaptureEnumMediaTypes::QueryInterface, COMDAT

; 397  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 398  :     if(riid == IID_IUnknown || riid == IID_IEnumMediaTypes)

	mov	esi, DWORD PTR _riid$[ebp]
	mov	ecx, OFFSET _IID_IUnknown
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN2@QueryInter
	mov	ecx, OFFSET _IID_IEnumMediaTypes
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN2@QueryInter

; 403  :     }
; 404  :     else
; 405  :     {
; 406  :         *ppv = NULL;

	mov	eax, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [eax], 0

; 407  :         return E_NOINTERFACE;

	mov	eax, -2147467262			; 80004002H
	pop	esi

; 408  :     }
; 409  : }

	pop	ebp
	ret	12					; 0000000cH
$LN2@QueryInter:

; 399  :     {
; 400  :         AddRef();

	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx

; 401  :         *ppv = (IEnumMediaTypes*)this;

	mov	eax, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [eax], esi

; 402  :         return NOERROR;

	xor	eax, eax
	pop	esi

; 408  :     }
; 409  : }

	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@CaptureEnumMediaTypes@@UAGJABU_GUID@@PAPAX@Z ENDP ; CaptureEnumMediaTypes::QueryInterface
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCaptureEnumMediaTypes@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCaptureEnumMediaTypes@@UAEPAXI@Z PROC		; CaptureEnumMediaTypes::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumMediaTypes@@6B@
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN10@scalar@2
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
$LN10@scalar@2:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCaptureEnumMediaTypes@@UAEPAXI@Z ENDP		; CaptureEnumMediaTypes::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z$0
__ehfuncinfo$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z
_TEXT	SEGMENT
$T106248 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z PROC	; CaptureEnumPins::Clone, COMDAT

; 377  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 378  :     *ppEnum = new CaptureEnumPins(filter, this);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	16					; 00000010H
	call	eax
	mov	esi, eax
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR $T106248[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	cmp	esi, eax
	je	SHORT $LN3@Clone@2
	mov	edi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumPins@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, esi
$LN3@Clone@2:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppEnum$[ebp]
	mov	DWORD PTR [ecx], eax

; 379  :     return (*ppEnum == NULL) ? E_OUTOFMEMORY : NOERROR;

	neg	eax
	sbb	eax, eax
	and	eax, 2147024882				; 7ff8fff2H
	add	eax, -2147024882			; 8007000eH

; 380  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z$0:
	mov	eax, DWORD PTR $T106248[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Clone@CaptureEnumPins@@UAGJPAPAUIEnumPins@@@Z ENDP	; CaptureEnumPins::Clone
; Function compile flags: /Ogtp
;	COMDAT ?QueryInterface@CaptureEnumPins@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?QueryInterface@CaptureEnumPins@@UAGJABU_GUID@@PAPAX@Z PROC ; CaptureEnumPins::QueryInterface, COMDAT

; 338  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 339  :     if(riid == IID_IUnknown || riid == IID_IEnumPins)

	mov	esi, DWORD PTR _riid$[ebp]
	mov	ecx, OFFSET _IID_IUnknown
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN2@QueryInter@2
	mov	ecx, OFFSET _IID_IEnumPins
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN2@QueryInter@2

; 344  :     }
; 345  :     else
; 346  :     {
; 347  :         *ppv = NULL;

	mov	eax, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [eax], 0

; 348  :         return E_NOINTERFACE;

	mov	eax, -2147467262			; 80004002H
	pop	esi

; 349  :     }
; 350  : }

	pop	ebp
	ret	12					; 0000000cH
$LN2@QueryInter@2:

; 340  :     {
; 341  :         AddRef();

	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx

; 342  :         *ppv = (IEnumPins*)this;

	mov	eax, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [eax], esi

; 343  :         return NOERROR;

	xor	eax, eax
	pop	esi

; 349  :     }
; 350  : }

	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@CaptureEnumPins@@UAGJABU_GUID@@PAPAX@Z ENDP ; CaptureEnumPins::QueryInterface
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCaptureEnumPins@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCaptureEnumPins@@UAEPAXI@Z PROC			; CaptureEnumPins::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumPins@@6B@
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN10@scalar@3
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
$LN10@scalar@3:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCaptureEnumPins@@UAEPAXI@Z ENDP			; CaptureEnumPins::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z$0
__ehfuncinfo$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z
_TEXT	SEGMENT
$T106322 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z PROC	; CaptureFilter::EnumPins, COMDAT

; 303  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 304  :     *ppEnum = new CaptureEnumPins(this, NULL);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	16					; 00000010H
	call	eax
	mov	esi, eax
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR $T106322[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	test	esi, esi
	je	SHORT $LN3@EnumPins
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumPins@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
	mov	DWORD PTR [esi+12], 0
	mov	eax, esi
	jmp	SHORT $LN4@EnumPins
$LN3@EnumPins:
	xor	eax, eax
$LN4@EnumPins:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppEnum$[ebp]
	mov	DWORD PTR [ecx], eax

; 305  :     return (*ppEnum == NULL) ? E_OUTOFMEMORY : NOERROR;

	neg	eax
	sbb	eax, eax
	and	eax, 2147024882				; 7ff8fff2H
	add	eax, -2147024882			; 8007000eH

; 306  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z$0:
	mov	eax, DWORD PTR $T106322[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumPins@CaptureFilter@@UAGJPAPAUIEnumPins@@@Z ENDP	; CaptureFilter::EnumPins
; Function compile flags: /Ogtp
;	COMDAT ?QueryInterface@CaptureFilter@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?QueryInterface@CaptureFilter@@UAGJABU_GUID@@PAPAX@Z PROC ; CaptureFilter::QueryInterface, COMDAT

; 255  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 256  :     if(riid == IID_IUnknown)

	mov	esi, DWORD PTR _riid$[ebp]
	mov	ecx, OFFSET _IID_IUnknown
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN5@QueryInter@3
$LN16@QueryInter@3:

; 257  :     {
; 258  :         AddRef();

	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx

; 259  :         *ppv = (IUnknown*)this;

	mov	edx, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [edx], esi

; 260  :         return NOERROR;

	xor	eax, eax
	pop	esi

; 284  :     }
; 285  : }

	pop	ebp
	ret	12					; 0000000cH
$LN5@QueryInter@3:

; 261  :     }
; 262  :     if(riid == IID_IPersist)

	mov	ecx, OFFSET _IID_IPersist
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax

; 263  :     {
; 264  :         AddRef();
; 265  :         *ppv = (IPersist*)this;
; 266  :         return NOERROR;

	jne	SHORT $LN16@QueryInter@3

; 267  :     }
; 268  :     if(riid == IID_IMediaFilter)

	mov	ecx, OFFSET _IID_IMediaFilter
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax

; 269  :     {
; 270  :         AddRef();
; 271  :         *ppv = (IMediaFilter*)this;
; 272  :         return NOERROR;

	jne	SHORT $LN16@QueryInter@3

; 273  :     }
; 274  :     if(riid == IID_IBaseFilter)

	mov	ecx, OFFSET _IID_IBaseFilter
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax

; 275  :     {
; 276  :         AddRef();
; 277  :         *ppv = (IBaseFilter*)this;
; 278  :         return NOERROR;

	jne	SHORT $LN16@QueryInter@3

; 279  :     }
; 280  :     else
; 281  :     {
; 282  :         *ppv = NULL;

	mov	eax, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [eax], 0

; 283  :         return E_NOINTERFACE;

	mov	eax, -2147467262			; 80004002H
	pop	esi

; 284  :     }
; 285  : }

	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@CaptureFilter@@UAGJABU_GUID@@PAPAX@Z ENDP ; CaptureFilter::QueryInterface
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCaptureFilter@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCaptureFilter@@UAEPAXI@Z PROC			; CaptureFilter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi], OFFSET ??_7CaptureFilter@@6B@
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN10@scalar@4
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
$LN10@scalar@4:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCaptureFilter@@UAEPAXI@Z ENDP			; CaptureFilter::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z ; CaptureFilter::CaptureFilter
;	COMDAT xdata$x
; File c:\users\beeanyew\documents\github\obs\obsapi\utility\inline.h
xdata$x	SEGMENT
__unwindtable$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z$0
__ehfuncinfo$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\capturefilter.cpp
xdata$x	ENDS
;	COMDAT ??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z
_TEXT	SEGMENT
$T106402 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_source$ = 8						; size = 4
_expectedMajorType$ = 12				; size = 4
_expectedMediaType$ = 16				; size = 4
??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z PROC ; CaptureFilter::CaptureFilter, COMDAT
; _this$ = esi

; 244  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 245  :     pin = new CapturePin(this, source, expectedMajorType, expectedMediaType);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	DWORD PTR [esi], OFFSET ??_7CaptureFilter@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+8], 0
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	128					; 00000080H
	call	eax
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], ecx
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ecx
	mov	DWORD PTR [eax+88], ecx
	mov	DWORD PTR [eax+92], ecx
	mov	DWORD PTR [eax+96], ecx
	mov	DWORD PTR [eax+100], ecx
	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+108], ecx
	mov	DWORD PTR [eax+112], ecx
	mov	DWORD PTR [eax+116], ecx
	mov	DWORD PTR [eax+120], ecx
	mov	DWORD PTR [eax+124], ecx
	mov	DWORD PTR $T106402[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], ecx
	test	eax, eax
	je	SHORT $LN3@CaptureFil
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _expectedMediaType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _expectedMajorType$[ebp]
	push	esi
	call	??0CapturePin@@QAE@PAVCaptureFilter@@PAVDeviceSource@@ABU_GUID@@2@Z ; CapturePin::CapturePin
	jmp	SHORT $LN4@CaptureFil
$LN3@CaptureFil:
	xor	eax, eax
$LN4@CaptureFil:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+16], eax

; 246  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z$0:
	mov	eax, DWORD PTR $T106402[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CaptureFilter@@QAE@PAVDeviceSource@@ABU_GUID@@1@Z ENDP ; CaptureFilter::CaptureFilter
; Function compile flags: /Ogtp
;	COMDAT ?Receive@CapturePin@@UAGJPAUIMediaSample@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pSample$ = 12						; size = 4
?Receive@CapturePin@@UAGJPAUIMediaSample@@@Z PROC	; CapturePin::Receive, COMDAT

; 197  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 198  :     if(pSample)

	mov	edi, DWORD PTR _pSample$[ebp]
	test	edi, edi
	je	SHORT $LN12@Receive

; 199  :     {
; 200  :         if(expectedMajorType == MEDIATYPE_Video)

	push	ebx
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, OFFSET _MEDIATYPE_Video
	lea	edx, DWORD PTR [esi+8]
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN3@Receive

; 201  :             source->ReceiveMediaSample(pSample, false);

	mov	eax, DWORD PTR [esi+40]
	push	0
	push	eax
	mov	ecx, edi
	call	?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z ; DeviceSource::ReceiveMediaSample
	pop	esi
	pop	ebx

; 204  :     }
; 205  :     return S_OK;

	xor	eax, eax
	pop	edi

; 206  : }

	pop	ebp
	ret	8
$LN3@Receive:

; 202  :         else if(expectedMajorType == MEDIATYPE_Audio)

	mov	ecx, OFFSET _MEDIATYPE_Audio
	lea	edx, DWORD PTR [esi+8]
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN11@Receive

; 203  :             source->ReceiveMediaSample(pSample, true);

	mov	ecx, DWORD PTR [esi+40]
	push	1
	push	ecx
	mov	ecx, edi
	call	?ReceiveMediaSample@DeviceSource@@AAEXPAUIMediaSample@@_N@Z ; DeviceSource::ReceiveMediaSample
$LN11@Receive:
	pop	esi
	pop	ebx
$LN12@Receive:

; 204  :     }
; 205  :     return S_OK;

	xor	eax, eax
	pop	edi

; 206  : }

	pop	ebp
	ret	8
?Receive@CapturePin@@UAGJPAUIMediaSample@@@Z ENDP	; CapturePin::Receive
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z$0
__ehfuncinfo$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z
_TEXT	SEGMENT
$T106459 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z PROC ; CapturePin::EnumMediaTypes, COMDAT

; 172  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 173  :     *ppEnum = new CaptureEnumMediaTypes(this, NULL);

	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	push	12					; 0000000cH
	call	eax
	mov	esi, eax
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR $T106459[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	cmp	esi, eax
	je	SHORT $LN4@EnumMediaT
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7CaptureEnumMediaTypes@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	DWORD PTR [esi+8], eax
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
	mov	eax, esi
$LN4@EnumMediaT:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _ppEnum$[ebp]
	mov	DWORD PTR [ecx], eax

; 174  :     if(!*ppEnum)

	neg	eax
	sbb	eax, eax
	and	eax, 2147024882				; 7ff8fff2H
	add	eax, -2147024882			; 8007000eH

; 175  :         return E_OUTOFMEMORY;
; 176  : 
; 177  :     return NOERROR;
; 178  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z$0:
	mov	eax, DWORD PTR $T106459[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumMediaTypes@CapturePin@@UAGJPAPAUIEnumMediaTypes@@@Z ENDP ; CapturePin::EnumMediaTypes
; Function compile flags: /Ogtp
;	COMDAT ?QueryPinInfo@CapturePin@@UAGJPAU_PinInfo@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pInfo$ = 12						; size = 4
?QueryPinInfo@CapturePin@@UAGJPAU_PinInfo@@@Z PROC	; CapturePin::QueryPinInfo, COMDAT

; 137  : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 138  :     pInfo->pFilter = filter;

	mov	ebx, DWORD PTR _pInfo$[ebp]
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [ebx], eax

; 139  :     if(filter) filter->AddRef();

	cmp	DWORD PTR [esi+48], 0
	push	edi
	je	SHORT $LN3@QueryPinIn
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	call	edx
$LN3@QueryPinIn:

; 140  : 
; 141  :     if(expectedMajorType == MEDIATYPE_Video)

	lea	edx, DWORD PTR [esi+12]
	mov	ecx, OFFSET _MEDIATYPE_Video
	call	_IsEqualGUID

; 142  :         mcpy(pInfo->achName, VIDEO_PIN_NAME, sizeof(VIDEO_PIN_NAME));

	lea	edi, DWORD PTR [ebx+8]
	mov	ecx, 7
	mov	esi, OFFSET $SG-341
	test	eax, eax
	jne	SHORT $LN8@QueryPinIn

; 143  :     else
; 144  :         mcpy(pInfo->achName, AUDIO_PIN_NAME, sizeof(AUDIO_PIN_NAME));

	mov	esi, OFFSET $SG-342
$LN8@QueryPinIn:
	rep movsd
	pop	edi

; 145  : 
; 146  :     pInfo->dir = PINDIR_INPUT;
; 147  : 
; 148  :     return NOERROR;

	xor	eax, eax
	pop	esi
	mov	DWORD PTR [ebx+4], eax
	pop	ebx

; 149  : }

	pop	ebp
	ret	8
?QueryPinInfo@CapturePin@@UAGJPAU_PinInfo@@@Z ENDP	; CapturePin::QueryPinInfo
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?QueryInterface@CapturePin@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?QueryInterface@CapturePin@@UAGJABU_GUID@@PAPAX@Z PROC	; CapturePin::QueryInterface, COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 49   :     if(riid == IID_IUnknown || riid == IID_IPin)

	mov	esi, DWORD PTR _riid$[ebp]
	mov	ecx, OFFSET _IID_IUnknown
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN4@QueryInter@4
	mov	ecx, OFFSET _IID_IPin
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN4@QueryInter@4

; 54   :     }
; 55   :     else if(riid == IID_IMemInputPin)

	mov	ecx, OFFSET _IID_IMemInputPin
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN2@QueryInter@4

; 56   :     {
; 57   :         AddRef();

	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	esi
	call	ecx

; 58   :         *ppv = (IMemInputPin*)this;

	mov	edx, DWORD PTR _ppv$[ebp]
	add	esi, 4
	mov	DWORD PTR [edx], esi
	xor	eax, eax
	pop	esi

; 65   :     }
; 66   : }

	pop	ebp
	ret	12					; 0000000cH
$LN2@QueryInter@4:

; 59   :         return NOERROR;
; 60   :     }
; 61   :     else
; 62   :     {
; 63   :         *ppv = NULL;

	mov	eax, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [eax], 0

; 64   :         return E_NOINTERFACE;

	mov	eax, -2147467262			; 80004002H
	pop	esi

; 65   :     }
; 66   : }

	pop	ebp
	ret	12					; 0000000cH
$LN4@QueryInter@4:

; 50   :     {
; 51   :         AddRef();

	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	call	edx

; 52   :         *ppv = (IPin*)this;

	mov	eax, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [eax], esi

; 53   :         return NOERROR;

	xor	eax, eax
	pop	esi

; 65   :     }
; 66   : }

	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@CapturePin@@UAGJABU_GUID@@PAPAX@Z ENDP	; CapturePin::QueryInterface
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCapturePin@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCapturePin@@UAEPAXI@Z PROC				; CapturePin::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CapturePin@@6BIPin@@@
	mov	DWORD PTR [esi+4], OFFSET ??_7CapturePin@@6BIMemInputPin@@@
	cmp	DWORD PTR [esi+116], 0
	je	SHORT $LN7@scalar@5
	mov	eax, DWORD PTR [esi+120]
	push	eax
	call	DWORD PTR __imp__CoTaskMemFree@4
	mov	DWORD PTR [esi+116], 0
	mov	DWORD PTR [esi+120], 0
$LN7@scalar@5:
	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN6@scalar@5
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
	mov	DWORD PTR [esi+112], 0
$LN6@scalar@5:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN14@scalar@5
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
$LN14@scalar@5:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GCapturePin@@UAEPAXI@Z ENDP				; CapturePin::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GSampleData@@QAEPAXI@Z
_TEXT	SEGMENT
??_GSampleData@@QAEPAXI@Z PROC				; SampleData::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+12]
	push	eax
	call	edx
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
	mov	eax, esi
	ret	0
??_GSampleData@@QAEPAXI@Z ENDP				; SampleData::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.h
_TEXT	ENDS
;	COMDAT ?Release@SampleData@@QAEXXZ
_TEXT	SEGMENT
?Release@SampleData@@QAEXXZ PROC			; SampleData::Release, COMDAT
; _this$ = esi

; 54   :         if(!InterlockedDecrement(&refs))

	lea	eax, DWORD PTR [esi+24]
	push	eax
	call	DWORD PTR __imp__InterlockedDecrement@4
	test	eax, eax
	jne	SHORT $LN15@Release@5

; 55   :             delete this;

	test	esi, esi
	je	SHORT $LN15@Release@5
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+12]
	push	eax
	call	edx
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	esi
	call	eax
$LN15@Release@5:

; 56   :     }

	ret	0
?Release@SampleData@@QAEXXZ ENDP			; SampleData::Release
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.0\include\shared\guiddef.h
_TEXT	ENDS
;	COMDAT _!=
_TEXT	SEGMENT
_!=	PROC						; COMDAT
; _guidOne$ = edx
; _guidOther$ = ecx

; 199  :     return !(guidOne == guidOther);

	call	_IsEqualGUID
	neg	eax
	sbb	eax, eax
	inc	eax

; 200  : }

	ret	0
_!=	ENDP
; Function compile flags: /Odtp
;	COMDAT ?QueryInterface@CapturePin@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CapturePin@@W3AGJABU_GUID@@PAPAX@Z PROC	; [thunk]:CapturePin::QueryInterface`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?QueryInterface@CapturePin@@UAGJABU_GUID@@PAPAX@Z ; CapturePin::QueryInterface
?QueryInterface@CapturePin@@W3AGJABU_GUID@@PAPAX@Z ENDP	; [thunk]:CapturePin::QueryInterface`adjustor{4}'
_TEXT	ENDS
PUBLIC	?IsValidMediaType@CapturePin@@ABE_NPBU_AMMediaType@@@Z ; CapturePin::IsValidMediaType
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\capturefilter.cpp
;	COMDAT ?IsValidMediaType@CapturePin@@ABE_NPBU_AMMediaType@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?IsValidMediaType@CapturePin@@ABE_NPBU_AMMediaType@@@Z PROC ; CapturePin::IsValidMediaType, COMDAT
; _pmt$ = esi

; 219  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi

; 220  :     if(pmt->pbFormat)

	mov	edi, DWORD PTR [esi+68]
	test	edi, edi
	je	SHORT $LN2@IsValidMed

; 221  :     {
; 222  :         if(pmt->subtype != expectedMediaType || pmt->majortype != expectedMajorType)

	mov	ebx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ebx+28]
	lea	edx, DWORD PTR [esi+16]
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN1@IsValidMed
	lea	ecx, DWORD PTR [ebx+12]
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN1@IsValidMed

; 223  :             return false;
; 224  : 
; 225  :         if(expectedMajorType == MEDIATYPE_Video)

	mov	ecx, OFFSET _MEDIATYPE_Video
	lea	edx, DWORD PTR [ebx+12]
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN2@IsValidMed

; 226  :         {
; 227  :             VIDEOINFOHEADER *pVih = reinterpret_cast<VIDEOINFOHEADER*>(pmt->pbFormat);
; 228  :             if( pVih->bmiHeader.biHeight == 0 ||
; 229  :                 pVih->bmiHeader.biWidth  == 0)

	cmp	DWORD PTR [edi+56], 0
	je	SHORT $LN1@IsValidMed
	cmp	DWORD PTR [edi+52], 0
	jne	SHORT $LN2@IsValidMed
$LN1@IsValidMed:
	pop	edi

; 230  :             {
; 231  :                 return false;

	xor	al, al
	pop	ebx

; 237  : }

	pop	ebp
	ret	4
$LN2@IsValidMed:
	pop	edi

; 232  :             }
; 233  :         }
; 234  :     }
; 235  : 
; 236  :     return true;

	mov	al, 1
	pop	ebx

; 237  : }

	pop	ebp
	ret	4
?IsValidMediaType@CapturePin@@ABE_NPBU_AMMediaType@@@Z ENDP ; CapturePin::IsValidMediaType
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?QueryAccept@CapturePin@@UAGJPBU_AMMediaType@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pmt$ = 12						; size = 4
?QueryAccept@CapturePin@@UAGJPBU_AMMediaType@@@Z PROC	; CapturePin::QueryAccept, COMDAT

; 154  : {

	push	ebp
	mov	ebp, esp
	push	edi

; 155  :     if(filter->state != State_Stopped)

	mov	edi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edi+48]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN4@QueryAccep

; 156  :         return S_FALSE;

	mov	eax, 1
	pop	edi

; 169  : }

	pop	ebp
	ret	8
$LN4@QueryAccep:
	push	ebx

; 157  :     if(pmt->majortype != expectedMajorType)

	mov	ebx, DWORD PTR _pmt$[ebp]
	lea	ecx, DWORD PTR [edi+12]
	mov	edx, ebx
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN3@QueryAccep

; 158  :         return S_FALSE;

	pop	ebx
	mov	eax, 1
	pop	edi

; 169  : }

	pop	ebp
	ret	8
$LN3@QueryAccep:
	push	esi

; 159  :     if(!IsValidMediaType(pmt))

	push	edi
	mov	esi, ebx
	call	?IsValidMediaType@CapturePin@@ABE_NPBU_AMMediaType@@@Z ; CapturePin::IsValidMediaType
	test	al, al
	jne	SHORT $LN2@QueryAccep

; 160  :         return S_FALSE;

	pop	esi
	pop	ebx
	mov	eax, 1
	pop	edi

; 169  : }

	pop	ebp
	ret	8
$LN2@QueryAccep:

; 161  : 
; 162  :     if(connectedPin)

	cmp	DWORD PTR [edi+124], 0
	je	SHORT $LN1@QueryAccep

; 163  :     {
; 164  :         FreeMediaType(connectedMediaType);

	lea	esi, DWORD PTR [edi+52]
	call	?FreeMediaType@@YGXAAU_AMMediaType@@@Z	; FreeMediaType

; 165  :         CopyMediaType(&connectedMediaType, pmt);

	push	ebx
	mov	eax, esi
	call	?CopyMediaType@@YGJPAU_AMMediaType@@PBU1@@Z ; CopyMediaType
$LN1@QueryAccep:

; 166  :     }
; 167  : 
; 168  :     return S_OK;

	pop	esi
	pop	ebx
	xor	eax, eax
	pop	edi

; 169  : }

	pop	ebp
	ret	8
?QueryAccept@CapturePin@@UAGJPBU_AMMediaType@@@Z ENDP	; CapturePin::QueryAccept
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?Connect@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pReceivePin$ = 12					; size = 4
_pmt$ = 16						; size = 4
?Connect@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z PROC ; CapturePin::Connect, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	push	edi

; 74   :     if(filter->state == State_Running)

	mov	edi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edi+48]
	cmp	DWORD PTR [eax+8], 2
	jne	SHORT $LN5@Connect

; 75   :         return VFW_E_NOT_STOPPED;

	mov	eax, -2147220956			; 80040224H
	pop	edi

; 86   : }

	pop	ebp
	ret	12					; 0000000cH
$LN5@Connect:

; 76   :     if(connectedPin)

	cmp	DWORD PTR [edi+124], 0
	je	SHORT $LN4@Connect

; 77   :         return VFW_E_ALREADY_CONNECTED;

	mov	eax, -2147220988			; 80040204H
	pop	edi

; 86   : }

	pop	ebp
	ret	12					; 0000000cH
$LN4@Connect:
	push	esi

; 78   :     if(!pmt)

	mov	esi, DWORD PTR _pmt$[ebp]
	test	esi, esi

; 79   :         return S_OK;

	je	SHORT $LN1@Connect

; 80   :     if(pmt->majortype != GUID_NULL && pmt->majortype != expectedMajorType)

	mov	ecx, OFFSET _GUID_NULL
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	jne	SHORT $LN2@Connect
	lea	ecx, DWORD PTR [edi+12]
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax

; 81   :         return S_FALSE;

	je	SHORT $LN19@Connect
$LN2@Connect:

; 82   :     if(pmt->majortype == expectedMajorType && !IsValidMediaType(pmt))

	lea	ecx, DWORD PTR [edi+12]
	mov	edx, esi
	call	_IsEqualGUID
	test	eax, eax
	je	SHORT $LN1@Connect
	push	edi
	call	?IsValidMediaType@CapturePin@@ABE_NPBU_AMMediaType@@@Z ; CapturePin::IsValidMediaType
	test	al, al
	jne	SHORT $LN1@Connect
$LN19@Connect:
	pop	esi

; 83   :         return S_FALSE;

	mov	eax, 1
	pop	edi

; 86   : }

	pop	ebp
	ret	12					; 0000000cH
$LN1@Connect:
	pop	esi

; 84   : 
; 85   :     return S_OK;

	xor	eax, eax
	pop	edi

; 86   : }

	pop	ebp
	ret	12					; 0000000cH
?Connect@CapturePin@@UAGJPAUIPin@@PBU_AMMediaType@@@Z ENDP ; CapturePin::Connect
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\devicesource.h
_TEXT	ENDS
;	COMDAT ?FlushSamples@DeviceSource@@AAEXXZ
_TEXT	SEGMENT
?FlushSamples@DeviceSource@@AAEXXZ PROC			; DeviceSource::FlushSamples, COMDAT
; _this$ = esi

; 184  :         OSEnterMutex(hSampleMutex);

	mov	eax, DWORD PTR [esi+208]
	push	ebx
	push	edi
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 185  :         for (UINT i=0; i<samples.Num(); i++)

	xor	edi, edi
	cmp	edi, DWORD PTR [esi+228]
	jae	SHORT $LN2@FlushSampl

; 186  :             delete samples[i];

$LN11@FlushSampl:
	mov	ecx, DWORD PTR [esi+224]
	mov	ebx, DWORD PTR [ecx+edi*4]
	lea	eax, DWORD PTR [ecx+edi*4]
	test	ebx, ebx
	je	SHORT $LN3@FlushSampl
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+12]
	push	edx
	call	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	ebx
	call	eax
$LN3@FlushSampl:

; 185  :         for (UINT i=0; i<samples.Num(); i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+228]
	jb	SHORT $LN11@FlushSampl
	xor	edi, edi
$LN2@FlushSampl:

; 187  :         samples.Clear();

	mov	eax, DWORD PTR [esi+224]
	cmp	eax, edi
	je	SHORT $LN25@FlushSampl
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR [esi+224], edi
	mov	DWORD PTR [esi+228], edi
$LN25@FlushSampl:

; 188  :         SafeRelease(latestVideoSample);

	mov	ebx, DWORD PTR [esi+220]
	cmp	ebx, edi
	je	SHORT $LN1@FlushSampl
	lea	ecx, DWORD PTR [ebx+24]
	push	ecx
	call	DWORD PTR __imp__InterlockedDecrement@4
	test	eax, eax
	jne	SHORT $LN44@FlushSampl
	cmp	ebx, edi
	je	SHORT $LN44@FlushSampl
	mov	edx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+12]
	push	edx
	call	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	ebx
	call	eax
$LN44@FlushSampl:
	mov	DWORD PTR [esi+220], edi
$LN1@FlushSampl:

; 189  :         OSLeaveMutex(hSampleMutex);

	mov	ecx, DWORD PTR [esi+208]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
	pop	edi
	pop	ebx

; 190  :     }

	ret	0
?FlushSamples@DeviceSource@@AAEXXZ ENDP			; DeviceSource::FlushSamples
; Function compile flags: /Ogtp
; File c:\users\beeanyew\documents\github\obs\dshowaudioplugin\capturefilter.cpp
;	COMDAT ?EndFlush@CapturePin@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?EndFlush@CapturePin@@UAGJXZ PROC			; CapturePin::EndFlush, COMDAT

; 184  : {

	push	ebp
	mov	ebp, esp

; 185  :     source->FlushSamples();

	mov	eax, DWORD PTR _this$[ebp]
	push	esi
	mov	esi, DWORD PTR [eax+44]
	call	?FlushSamples@DeviceSource@@AAEXXZ	; DeviceSource::FlushSamples

; 186  :     return S_OK;

	xor	eax, eax
	pop	esi

; 187  : }

	pop	ebp
	ret	4
?EndFlush@CapturePin@@UAGJXZ ENDP			; CapturePin::EndFlush
END
